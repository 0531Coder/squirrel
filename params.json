{"name":"Squirrel State Machine","tagline":"squirrel-foundation provided an easy use, type safe and highly extensible state machine implementation for Java.","body":"squirrel-foundation\r\n========\r\n\r\n## What is it?  \r\nJust like the squirrel, a **small**, **agile**, **smart**, **alert** and **cute** animal, squirrel-foundation is aimed to provide a **lightweright**, highly **flexible** and **extensible**, **diagnosable**, **easy use** and **type safe** Java state machine implementation for enterprise usage.  \r\n\r\nHere is the state machine diagram which describes the state change of an ATM:  \r\n\r\n![ATMStateMachine](http://hekailiang.github.io/squirrel/images/ATMStateMachine.png)  \r\nThe sample code could be found in package *\"org.squirrelframework.foundation.fsm.atm\"*.\r\n\r\n## Maven  \r\nsquirrel-foundation has been deployed to maven central repository, so you only need to add following  dependency to the pom.xml.\r\n\r\nLatest Released Version:\r\n```maven\r\n<dependency>\r\n\t<groupId>org.squirrelframework</groupId>\r\n  \t<artifactId>squirrel-foundation</artifactId>\r\n  \t<version>0.2.2.5</version>\r\n</dependency>\r\n``` \r\n\r\nLatest Snapshot Version:\r\n```maven\r\n<dependency>\r\n\t<groupId>org.squirrelframework</groupId>\r\n  \t<artifactId>squirrel-foundation</artifactId>\r\n  \t<version>0.2.3-SNAPSHOT</version>\r\n</dependency>\r\n``` \r\n\r\n\r\n## User Guide \r\n\r\n### Get Starting  \r\n**squirrel-foundation** supports both fluent API and declarative manner to declare a state machine, and also enable user to define the action methods in a straightforward manner. \r\n\r\n* **StateMachine** interface takes four generic type parameters.  \r\n\t* **T** stands for the type of implemented state machine.\r\n\t* **S** stands for the type of implemented state.\r\n\t* **E** stands for the type of implemented event.\r\n\t* **C** stands for the type of implemented external context.\r\n\r\n* **State Machine Builder**  \r\n\t- State machine builder is used to generate state machine definition. StateMachineBuilder can be created by StateMachineBuilderFactory.   \r\n\t- The StateMachineBuilder is composed of *TransitionBuilder (InternalTransitionBuilder / LocalTransitionBuilder / ExternalTransitionBuilder) which is used to build transition between states, and EntryExitActionBuilder which is used to build the actions during entry or exit state. \r\n\t- The internal state is implicitly built during transition creation or state action creation.   \r\n\t\r\n\tIn order to create a state machine, user need to create state machine builder first. For example:   \r\n\t```java\r\n\tStateMachineBuilder<MyStateMachine, MyState, MyEvent, MyContext> builder =\r\n\t\tStateMachineBuilderFactory.create(MyStateMachine.class, MyState.class, MyEvent.class, MyContext.class);\r\n\t```\r\n\r\n* **Fluent API**  \r\nAfter state machine builder was created, we can use fluent API to define state/transition/action of the state machine.\r\n```java\r\nbuilder.externalTransition().from(MyState.A).to(MyState.B).on(MyEvent.GoToB);\r\n```\r\nAn **external transition** is built between state 'A' to state 'B' and triggered on received event 'GoToB'.\r\n```java\r\nbuilder.internalTransition(TransitionPriority.HIGH).within(MyState.A).on(MyEvent.WithinA).perform(myAction);\r\n```\r\nAn **internal transition** with priority set to high is build inside state 'A' on event 'WithinA' perform 'myAction'. The internal transition means after transition complete, no state is exited or entered. The transition priority is used to override original transition when state machine extended.\r\n```java\r\n\tbuilder.externalTransition().from(MyState.C).to(MyState.D).on(MyEvent.GoToD).when(\r\n\t\tnew Condition<MyContext>() {\r\n            @Override\r\n            public boolean isSatisfied(MyContext context) {\r\n                return context!=null && context.getValue()>80;\r\n            }\r\n            \r\n\t\t\t@Override\r\n\t\t\tpublic String name() {\r\n\t\t\t\treturn \"MyCondition\";\r\n\t\t\t}\r\n    }).callMethod(\"myInternalTransitionCall\");\r\n```\r\nAn **conditional transition** is built from state 'C' to state 'D' on event 'GoToD' when external context satisfied the condition restriction, then call action method \"myInternalTransitionCall\". User can also use [MVEL][7](a powerful expression language) to describe condition in the following way.  \r\n```java\r\n\tbuilder.externalTransition().from(MyState.C).to(MyState.D).on(MyEvent.GoToD).whenMvel(\r\n\t\t\"MyCondition:::(context!=null && context.getValue()>80)\").callMethod(\"myInternalTransitionCall\");\r\n```\r\n**Note:** Characters ':::' use to separate condition name and condition expression. The 'context' is the predefined variable point to current Context object.    \r\n```java\r\nbuilder.onEntry(MyState.A).perform(Lists.newArrayList(action1, action2))\r\n```\r\nA list of state entry actions is defined.\r\n\r\n* **Method Call Action**  \r\n\tUser can define anonymous actions during define transitions or state entry/exit. However, the action code will be scattered over many places which may make code hard to maintain. Moreover, other user cannot override the actions. So squirrel-foundation also support to define state machine method call action which comes along with state machine class itself.   \r\n\t```java\r\n\tStateMachineBuilder<...> builder = StateMachineBuilderFactory.create(\r\n\t\tMyStateMachine.class, MyState.class, MyEvent.class, MyContext.class);\r\n\tbuilder.externalTransition().from(A).to(B).on(toB).callMethod(\"fromAToB\");\r\n\t\r\n\t// All transition action method stays with state machine class\r\n\tpublic class MyStateMachine<...> extends AbstractStateMachine<...> {\r\n\t\tprotected void fromAToB(MyState from, MyState to, MyEvent event, MyContext context) {\r\n\t\t\t// this method will be called during transition from \"A\" to \"B\" on event \"toB\"\r\n\t\t\t// the action method parameters types and order should match\r\n\t\t\t...\r\n\t\t}\r\n\t}\r\n\t```\r\n\t\r\n\tMoreover, squirrel-foundation also support define method call actions in a **Convention Over Configuration** manner. Basically, this means that if the method declared in state machine satisfied naming and parameters convention, it will be added into the transition action list and also be invoked at certain phase. e.g.  \r\n\t```java\r\n\tprotected void transitFromAToBOnGoToB(MyState from, MyState to, MyEvent event, MyContext context)\r\n\t```\r\n\tThe method named as **transitFrom\\[SourceStateName\\]To\\[TargetStateName\\]On\\[EventName\\]**, and parameterized as \\[MyState, MyState, MyEvent, MyContext\\] will be added into transition \"A-(GoToB)->B\" action list. When transiting from state 'A' to state 'B' on event 'GoToB', this method will be invoked.\r\n\t\r\n\t```java\r\n\tprotected void transitFromAnyToBOnGoToB(MyState from, MyState to, MyEvent event, MyContext context)\r\n\t```\r\n\t**transitFromAnyTo[TargetStateName]On[EventName]** The method will be invoked when transit from any state to state 'B' on event 'GoToB'.\r\n\t```java\r\n\tprotected void exitA(MyState from, MyState to, MyEvent event, MyContext context)\r\n\t```\r\n\t**exit[StateName]** The method will be invoked when exit state 'A'. So as the **entry[StateName]** , **exitAny** and **entryAny**.  \r\n\t\r\n\t***Other Supported Naming Patterns:***\r\n\t```\r\n\ttransitFrom[fromStateName]To[toStateName]On[eventName]When[conditionName]  \r\n    transitFrom[fromStateName]To[toStateName]On[eventName]  \r\n    transitFromAnyTo[toStateName]On[eventName]  \r\n    transitFrom[fromStateName]ToAnyOn[eventName]  \r\n    transitFrom[fromStateName]To[toStateName]          \r\n    on[eventName] \r\n    ```\r\n* **Declarative Annotation**  \r\nA declarative way is also provided to define and also to extend the state machine. Here is an example.  \r\n\t```java\r\n\t@States({\r\n        @State(name=\"A\", entryCallMethod=\"entryStateA\", exitCallMethod=\"exitStateA\"), \r\n        @State(name=\"B\", entryCallMethod=\"entryStateB\", exitCallMethod=\"exitStateB\")\r\n    })\r\n\t@Transitions({\r\n        @Transit(from=\"A\", to=\"B\", on=\"GoToB\", callMethod=\"stateAToStateBOnGotoB\"),\r\n        @Transit(from=\"A\", to=\"A\", on=\"WithinA\", callMethod=\"stateAToStateAOnWithinA\", type=TransitionType.INTERNAL)\r\n\t})\r\n\tinterface MyStateMachine extends StateMachine<MyStateMachine, MyState, MyEvent, MyContext> {\r\n\t\tvoid entryStateA(MyState from, MyState to, MyEvent event, MyContext context);\r\n\t\tvoid stateAToStateBOnGotoB(MyState from, MyState to, MyEvent event, MyContext context)\r\n\t\tvoid stateAToStateAOnWithinA(MyState from, MyState to, MyEvent event, MyContext context)\r\n\t\tvoid exitStateA(MyState from, MyState to, MyEvent event, MyContext context);\r\n\t\t...\r\n\t}\r\n\t```\r\n\tThe annotation can be defined in both implementation class of state machine or any interface that state machine will be implemented. It also can be used mixed with fluent API, which means the state machine defined in fluent API can also be extended by these annotations. (One thing you may need to be noticed, the method defined within interface must be public, which means also the method call action implementation will be public to caller.)  \r\n\t\r\n* **Converters**  \r\nIn order to declare state and event within *@State* and *@Transit*, user need to implement corresponding converters for their state(S) and event(E) type. The convert must implement Converter\\<T\\> interface, which convert the state/event to/from String.\r\n```java\r\npublic interface Converter<T> extends SquirrelComponent {\r\n    \t/**\r\n     \t* Convert object to string.\r\n     \t* @param obj converted object\r\n     \t* @return string description of object\r\n     \t*/\r\n    \tString convertToString(T obj);\r\n    \r\n    \t/**\r\n     \t* Convert string to object.\r\n     \t* @param name name of the object\r\n     \t* @return converted object\r\n     \t*/\r\n    \tT convertFromString(String name);\r\n}\r\n```  \r\nThen register these converters to *ConverterProvider*. e.g.\r\n```java\r\nConverterProvider.INSTANCE.register(MyEvent.class, new MyEventConverter());\r\nConverterProvider.INSTANCE.register(MyState.class, new MyStateConverter());\r\n```  \r\n\t*Note: If you only use fluent API to define state machine, there is no need to implement corresponding converters. And also if the Event or State class is type of String or Enumeration, you don't need to implement or register a converter explicitly at most of cases.*\r\n\t\r\n* **New State Machine Instance**  \r\nAfter user defined state machine behaviour, user could create a new state machine instance through builder. Note, once the state machine instance is created from the builder, the builder cannot used to define any new element of state machine anymore.\r\n```java\r\nT newStateMachine(S initialStateId, Object... extraParams);\r\n```\r\nTo create a new state machine instance from state machine builder, you need to pass following parameters.\r\n\t1. *initialStateId*: When started, the initial state of the state machine.\r\n\t2. *extraParams*: Extra parameters that needed for create new state machine instance. Set to *\"new Object[0]\"* for no extra parameters needed.  \r\n\t\r\n\tNew state machine from state machine builder.\r\n\t```java\r\n\tMyStateMachine stateMachine = builder.newStateMachine(MyState.Initial, new Object[0]);\r\n\t```\r\n\r\n* **Fire Events**  \r\n\tAfter state machine was created, user can fire events along with context to trigger transition inside state machine. e.g.\r\n\t```java\r\n\tstateMachine.fire(MyEvent.Prepare, new MyContext(\"Testing\"));\t\r\n\t```\r\n* **Untyped State Machine**  \r\n\tIn order to simplify state machine usage, and avoid too many generic types (e.g. StateMachine\\<T, S, E, C\\>) which may make code hard to read in some case, but still keep important part of type safety feature on transition action execution, UntypedStateMachine was implemented for this purpose.\r\n\t```java\r\n\tenum TestEvent {\r\n        toA, toB, toC, toD\r\n    }\r\n    \r\n\t@Transitions({\r\n        @Transit(from=\"A\", to=\"B\", on=\"toB\", callMethod=\"fromAToB\"),\r\n        @Transit(from=\"B\", to=\"C\", on=\"toC\"),\r\n        @Transit(from=\"C\", to=\"D\", on=\"toD\")\r\n    })\r\n    @StateMachineParamters(stateType=String.class, eventType=TestEvent.class, contextType=Integer.class)\r\n    class UntypedStateMachineSample extends AbstractUntypedStateMachine {\r\n        \r\n        protected UntypedStateMachineSample(ImmutableUntypedState initialState, \r\n        \tMap<Object, ImmutableUntypedState> states) {\r\n            super(initialState, states);\r\n        }\r\n        \r\n        protected void fromAToB(String from, String to, TestEvent event, Integer context) {\r\n            // transition action still type safe ...\r\n        }\r\n        \r\n        protected void transitFromDToAOntoA(String from, String to, TestEvent event, Integer context) {\r\n            // transition action still type safe ...\r\n        }\r\n    }\r\n    \r\n\tUntypedStateMachineBuilder builder = StateMachineBuilderFactory.create(\r\n\t\tUntypedStateMachineSample.class);\r\n\t// state machine builder not type safe anymore\r\n    builder.externalTransition().from(\"D\").to(\"A\").on(TestEvent.toA);\r\n    UntypedStateMachine fsm = builder.newStateMachine(\"A\");\r\n\t```\r\n\t*@StateMachineParamters* is used to declare state machine generic parameter types.  \r\n\t*AbstractUntypedStateMachine* is the base class of any untyped state machine.\r\n\r\n### Advanced Feature\r\n* **Define Hierarchical State**  \r\nA hierarchical state may contain nested state. The child states may themselves have nested children and the nesting may proceed to any depth. When a hierarchical state is active, one and only one of its child states is active. The hierarchical state can be defined through API or annotation.\r\n```java\r\nvoid defineSequentialStatesOn(S parentStateId, S... childStateIds);\r\n```\r\n*builder.defineSequentialStatesOn(State.A, State.BinA, StateCinA)* defines two child states \"BinA\" and \"CinA\" under parent state \"A\", the first defined child state will also be the initial state of the hierarchical state \"A\". The same hierarchical state can also be defined through annotation, e.g.\r\n```java\r\n@States({\r\n\t\t@State(name=\"A\", entryMethodCall=\"entryA\", exitMethodCall=\"exitA\"),\r\n\t\t@State(parent=\"A\", name=\"BinA\", entryMethodCall=\"entryBinA\", exitMethodCall=\"exitBinA\", initialState=true),\r\n\t\t@State(parent=\"A\", name=\"CinA\", entryMethodCall=\"entryCinA\", exitMethodCall=\"exitCinA\")\r\n})\r\n```  \r\n\r\n* **Define Parallel State**  \r\nThe parallel state encapsulates a set of child states which are simultaneously active when the parent element is active. The  parallel state can be defined through API or annotation both. e.g.  \r\n![ParallelStates](http://hekailiang.github.io/squirrel/images/ParallelStates.png)     \r\n```java  \r\n\t// defines two region states \"RegionState1\" and \"RegionState2\" under parent parallel state \"Root\"\r\n\tbuilder.defineParallelStatesOn(MyState.Root, MyState.RegionState1, MyState.RegionState2);\r\n\t\r\n\tbuilder.defineSequentialStatesOn(MyState.RegionState1, MyState.State11, MyState.State12);\r\n\tbuilder.externalTransition().from(MyState.State11).to(MyState.State12).on(MyEvent.Event1);\r\n\t\r\n\tbuilder.defineSequentialStatesOn(MyState.RegionState2, MyState.State21, MyState.State22);\r\n\tbuilder.externalTransition().from(MyState.State21).to(MyState.State22).on(MyEvent.Event2);\r\n```\r\nor  \r\n```java  \r\n@States({\r\n\t\t@State(name=\"Root\", entryCallMethod=\"enterRoot\", exitCallMethod=\"exitRoot\", compositeType=StateCompositeType.PARALLEL),\r\n\t\t@State(parent=\"Root\", name=\"RegionState1\", entryCallMethod=\"enterRegionState1\", exitCallMethod=\"exitRegionState1\"),\r\n\t\t@State(parent=\"Root\", name=\"RegionState2\", entryCallMethod=\"enterRegionState2\", exitCallMethod=\"exitRegionState2\")\r\n})\r\n```\r\nTo get current sub states of the parallel state\r\n```java\r\nstateMachine.getSubStatesOn(MyState.Root); // return list of current sub states of parallel state\r\n```\r\n\r\n* **Using History States to Save and Restore the Current State**  \r\nThe history pseudo-state allows a state machine to remember its state configuration. A transition taking the history state as its target will return the state machine to this recorded configuration. If the 'type' of a history is \"shallow\", the state machine processor must record the direct  active children of its parent before taking any transition that exits the parent. If the 'type' of a history is \"deep\", the state machine processor must record all the active  descendants of the parent before taking any transition that exits the parent.   \r\nBoth API and annotation are supported to define history type of state. e.g.  \r\n```java  \r\n\t// defined history type of state \"A\" as \"deep\"\r\n\tbuilder.defineSequentialStatesOn(MyState.A, HistoryType.DEEP, MyState.A1, MyState.A2)\r\n```\r\nor\r\n```java  \r\n\t@State(parent=\"A\", name=\"A1\", entryCallMethod=\"enterA1\", exitCallMethod=\"exitA1\", historyType=HistoryType.DEEP)\r\n```\r\n\r\n* **Transition Types**  \r\nAccording to the UML specification, a transition may be one of these three kinds:    \r\n\r\n\t> * *Internal Transition*  \t\r\nImplies that the Transition, if triggered, occurs without exiting or entering the source State (i.e., it does not cause a state change). This means that the entry or exit condition of the source State will not be invoked. An internal Transition can be taken even if the StateMachine is in one or more Regions nested within the associated State.  \r\n\t> * *Local Transition*  \r\n\tImplies that the Transition, if triggered, will not exit the composite (source) State, but it will exit and re-enter any state within the composite State that is in the current state configuration.\r\n\t> * *External Transition*   \r\n\tImplies that the Transition, if triggered, will exit the composite (source) State  \r\n\r\n\tsquirrel-foundation supports both API and annotation to declare all kinds of transitions, e.g.  \r\n\t```java\r\n\tbuilder.externalTransition().from(MyState.A).to(MyState.B).on(MyEvent.A2B);\r\n\tbuilder.internalTransition().within(MyState.A).on(MyEvent.innerA);\r\n\tbuilder.localTransition().from(MyState.A).to(MyState.CinA).on(MyEvent.intoC)\r\n\t```\r\n\tor  \r\n\t```java\r\n\t@Transitions({\r\n\t\t@Transition(from=\"A\", to=\"B\", on=\"A2B\"), //default value of transition type is EXTERNAL\r\n\t\t@Transition(from=\"A\", on=\"innerA\", type=TransitionType.INTERNAL),\r\n\t\t@Transition(from=\"A\", to=\"CinA\", on=\"intoC\", type=TransitionType.LOCAL),\r\n\t})\r\n\t```\r\n\r\n* **Polymorphism Event Dispatch**  \r\nDuring the lifecycle of the state machine, various events will be fired, e.g.   \r\n```  \r\nState Machine Lifecycle Events\r\n|--StateMachineEvent \t\t\t\t\t\t/* Base event of all state machine event */   \r\n       |--StartEvent\t\t\t\t\t\t\t/* Fired when state machine started      */ \r\n       |--TerminateEvent\t\t\t\t\t\t/* Fired when state machine terminated   */ \r\n       |--TransitionEvent\t\t\t\t\t\t/* Base event of all transition event    */ \r\n       \t\t|--TransitionBeginEvent\t\t\t\t/* Fired when transition began           */ \r\n            |--TransitionCompleteEvent\t\t\t/* Fired when transition completed       */ \r\n            |--TransitionExceptionEvent\t\t\t/* Fired when transition threw exception */ \r\n            |--TransitionDeclinedEvent\t\t\t/* Fired when transition declined        */ \r\n            |--TransitionEndEvent\t\t\t\t/* Fired when transition end no matter declined or complete */ \r\n```\r\nUser can add a listener to listen StateMachineEvent, which means all events fired during state machine lifecycle will be caught by this listener, e.g.,\r\n```java\r\nstateMachine.addStateMachineListener(new StateMachineListener<MyStateMachine, MyState, MyEvent, MyContext>() {\r\n\t\t\t@Override\r\n\t\t\tpublic void stateMachineEvent(StateMachineEvent<MyStateMachine, MyState, MyEvent, MyContext> event) {\r\n\t\t\t\t// ...\r\n\t\t\t}\r\n\t});\r\n```\r\n**And** User can also add a listener to listen TransitionEvent through StateMachine.addTransitionListener, which means all events fired during each state transition including TransitionBeginEvent, TransitionCompleteEvent and TransitionEndEvent will be caught by this listener.  \r\n**Or** user can add specific listener e.g. TransitionDeclinedListener to listen TransitionDeclinedEvent when transition request was declined.  \r\n* **Declarative Event Listener**  \r\nAdding above event listener to state machine sometime annoying to user, and too many generic types also makes code ugly to read. To simplify state machine usage, more important to provide a non-invasive integration, squirrel-foundation provides a declarative way to add event listener through following annotation, e.g.     \r\n```java\r\n\tstatic class ExtenalModule {\r\n        @OnTransitionEnd\r\n        public void transitionEnd() {\r\n            // method annotated with TransitionEnd will be invoked when transition end...\r\n            // the method must be public and return nothing\r\n        }\r\n        \r\n        @OnTransitionBegin\r\n        public void transitionBegin(TestEvent event) {\r\n            // method annotated with TransitionBegin will be invoked when transition begin...\r\n        }\r\n        \r\n\t\t// 'event'(E), 'from'(S), 'to'(S), 'context'(C) and 'stateMachine'(T) can be used in MVEL scripts\t\t\r\n\t\t@OnTransitionBegin(when=\"event.name().equals(\\\"toB\\\")\")\r\n        public void transitionBeginConditional() {\r\n            // method will be invoked when transition begin while transition caused by event \"toB\"\r\n        }\r\n        \r\n        @OnTransitionComplete\r\n        public void transitionComplete(String from, String to, TestEvent event, Integer context) {\r\n            // method annotated with TransitionComplete will be invoked when transition complete...\r\n        }\r\n        \r\n        @OnTransitionDecline\r\n        public void transitionDeclined(String from, TestEvent event, Integer context) {\r\n            // method annotated with TransitionDecline will be invoked when transition declined...\r\n        }\r\n    }\r\n    \r\n\tExtenalModule externalModule = new ExtenalModule();\r\n    fsm.addDeclarativeListener(externalModule);\r\n    ...\r\n    fsm.removeDeclarativeListener(externalModule);\r\n```\r\nBy doing this external module code does not need to implement any state machine listener interface. Only add few annotations on methods which will be hooked during transition phase. The parameters of method is also type safe, and will automatically be inferred to match corresponding event. This is a good approach for **Separation of Concerns**. User can find sample usage in *org.squirrelframework.foundation.fsm.StateMachineLogger*.\r\n\r\n* **Transition Extension Methods**   \r\nEach transition event also has corresponding extension method on AbstractStateMachine class which is allowed to be extended in customer state machine implementation class.  \r\n```java\r\n\tprotected void afterTransitionCausedException(Exception e, S fromState, S toState, E event, C context) {\r\n    }\r\n    \r\n\tprotected void beforeTransitionBegin(S fromState, E event, C context) {\r\n    }\r\n    \r\n    protected void afterTransitionCompleted(S fromState, S toState, E event, C context) {\r\n    }\r\n    \r\n    protected void afterTransitionEnd(S fromState, S toState, E event, C context) {\r\n    }\r\n    \r\n    protected void afterTransitionDeclined(S fromState, E event, C context) {\r\n    }\r\n```\r\nTypically, user can hook in your business processing logic in these extension methods during each state transition, while the various event listener serves as boundary of state machine based control system, which can interact with external modules (e.g. UI, Auditing, ESB and so on).  \r\nFor example, user can extend the method afterTransitionCausedException for environment clean up when exception happened during transition, and also notify user interface module to display error message  through TransitionExceptionEvent.\r\n\r\n* **State Machine PostProcessor**  \r\n\tUser can register post processor for specific type of state machine in order to adding post process logic after state machine instantiated, e.g.  \r\n\t```java\r\n\t// 1 User defined a state machine interface\r\n\tinterface MyStateMachine extends StateMachine<MyStateMachine, MyState, MyEvent, MyContext> {\r\n\t. . .\r\n\t}\r\n\t\r\n\t// 2 Both MyStateMachineImpl and MyStateMachineImplEx are implemented MyStateMachine\r\n\tclass MyStateMachineImpl implements MyStateMachine {\r\n\t\t. . . \r\n\t}\r\n\tclass MyStateMachineImplEx implements MyStateMachine {\r\n\t\t. . .\r\n\t}\r\n\t\r\n\t// 3 User define a state machine post processor\r\n\tMyStateMachinePostProcessor implements SquirrelPostProcessor<MyStateMachine> {\r\n\t\tvoid postProcess(MyStateMachine component) {\r\n\t\t\t. . . \r\n\t\t}\r\n\t}  \r\n\t\r\n\t// 4 User register state machine post process\r\n\tSquirrelPostProcessorProvider.getInstance().register(MyStateMachine.class, MyStateMachinePostProcessor.class);\r\n\t```\r\n\tFor this case, when user created both MyStateMachineImpl and MyStateMachineImplEx instance, the registered post processor MyStateMachinePostProcessor will be called to do some work.\r\n* **State Machine Intercepter**  \r\n\tUser can register intercepter for specific type of state machine to insert custom logic during state machine lifecycle. \r\n\t```java\r\n\tpublic abstract class AbstractStateMachineIntercepter<T extends StateMachine<T, S, E, C>, S, E, C> \r\n    \timplements StateMachineIntercepter<T, S, E, C>, SquirrelPostProcessor<T> {\r\n    \t. . .\r\n    }\r\n\t```\r\n\tUser can insert custom logic at different state machine process phases by creating a state machine intercepter which is extended from *AbstractStateMachineIntercepter*. Actually, the *AbstractStateMachineIntercepter* also implemented *SquirrelPostProcessor* interface. It will add a StateMachineEvent listener into the state machine, and dispatch the method call according to the event type. Thus, the StateMachineIntercepter registration should be the same as state machine post processor.   \r\n\tBy leveraging state machine intercepter, user can implement various monitors for performance analysis, exception diagnose and so on.  \r\n\t\r\n* **State Machine Export**  \r\nSCXMLVisitor can be used to export state machine definition in [SCXML] [2] document.\r\n```java  \r\nSCXMLVisitor<MyStateMachine, MyState, MyEvent, MyContext> visitor = SquirrelProvider.getInstance().newInstance(\r\n\t\t\t\tnew TypeReference<SCXMLVisitor<MyStateMachine, MyState, MyEvent, MyContext>>() {});\r\nstateMachine.accept(visitor);\r\nvisitor.convertSCXMLFile(\"MyStateMachine\", true);\r\n```\r\nDotVisitor can be used to generate state diagram which can be viewed by [GraphViz] [3].\r\n```java  \r\nDotVisitor<SnakeController, SnakeState, SnakeEvent, SnakeContext> visitor = SquirrelProvider.getInstance().newInstance(\r\n                new TypeReference<DotVisitor<SnakeController, SnakeState, SnakeEvent, SnakeContext>>() {});\r\nstateMachine.accept(visitor);\r\nvisitor.convertDotFile(\"SnakeStateMachine\");\r\n```\r\n\t\r\n* **Save/Load State Machine Data**  \r\nUser can save data of state machine when state machine is in idle status.\r\n``` java\r\nStateMachineData.Reader<MyStateMachine, MyState, MyEvent, MyContext> \r\n\t\tsavedData = stateMachine.dumpSavedData();\r\n```  \r\nAnd also user can load above *savedData* into another state machine whose status is terminated or just initialized.\r\n``` java \r\nnewStateMachineInstance.loadSavedData(savedData);\r\n``` \r\n\r\n* **State Machine Diagnose**  \r\n\t*StateMachineLogger* is used to observe internal status of the state machine, like the execution performance, action calling sequence, transition progress and so on, e.g.  \r\n\t```java\r\n\tStateMachine<?,?,?,?> stateMachine = builder.newStateMachine(HState.A);\r\n\tStateMachineLogger fsmLogger = new StateMachineLogger(stateMachine);\r\n\tfsmLogger.startLogging();\r\n\t...\r\n\tstateMachine.fire(HEvent.B2A, 1);\r\n\t...\r\n\tfsmLogger.terminateLogging();\r\n\t----------------------------------------------------------------------------------------\r\n\tConsole Log:\r\n\tHierachicalStateMachine: Transition from \"B2a\" on \"B2A\" with context \"1\" begin.\r\n\tBefore execute method call action \"leftB2a\" (1 of 6).\r\n\tBefore execute method call action \"exitB2\" (2 of 6).\r\n\t...\r\n\tBefore execute method call action \"entryA1\" (6 of 6).\r\n\tHierachicalStateMachine: Transition from \"B2a\" to \"A1\" on \"B2A\" complete which took 2ms.\r\n\t...\r\n\t```   \r\n\tAdd **@LogExecTime** on action method will log out the execution time of the method. And also add the @LogExecTime on state machine class will log out all the action method execution time. For example, the execution time of method *transitFromAToBOnGoToB* will be logged out.\r\n\t```java\r\n\t@LogExecTime\r\n\tprotected void transitFromAToBOnGoToB(MyState from, MyState to, MyEvent event, MyContext context)\r\n\t```\r\n\r\n* **Linked State (so called Submachine State)**  \r\n\tA **linked state** specifies the insertion of the specification of a submachine state machine. The state machine that contains the linked state is called the containing state machine. The same state machine may be a submachine more than once in the context of a single containing state machine.  \r\n\t  \r\n\tA linked state is semantically equivalent to a composite state. The regions of the submachine state machine are the regions of the composite state. The entry, exit, and behavior actions and internal transitions are defined as part of the state. Submachine state is a decomposition mechanism that allows factoring of common behaviors and their reuse.  \r\n\tThe linked state can be defined by following sample code.\r\n\t```java\r\n\tbuilderOfTestStateMachine.definedLinkedState(LState.A, builderOfLinkedStateMachine, LState.A1);\r\n\t```\r\n### Examples  \r\n* **ATM State Machine**  \r\nThe sample code could be found in package *\"org.squirrelframework.foundation.fsm.atm\"*.  \r\n\r\n* **Simple CSS Parser**  \r\n\tThis example illustrates how to parse incoming characters by define parser grammar in state machine.  \r\n\t![SimpleCssParser](http://hekailiang.github.io/squirrel/images/SimpleCssParser.png)  \r\n\tParse CSS scripts with *SimpleCssParser* which is defined as State Machine.\r\n\t```java\r\n\tSimpleCssParser parser = SimpleCssParser.newParser();\r\n    List<CssRule> rules = parser.parse(\"alpha { width: 100px/*comment1*/; /*comment2*/text-decoration: \" + \r\n    \t\"/*comment3*/ underlined; } epsilon/*comment4*/, zeta{ height: 34px; } \");\r\n\t```\r\n\tSample code to define CssParser could be found in package *\"org.squirrelframework.foundation.fsm.cssparser\"*.\r\n\r\n* **Greedy Snake Game Sample**  \r\n\tHere is an interesting example which used state machine to implement greedy snake game \tcontroller. The following diagram shows that the state machine definition of the controller.   \r\n\t![SnakeStateMachine](http://hekailiang.github.io/squirrel/images/SnakeGame.png)  \r\n\tSample code to create snake game state machine.\r\n\t```java\r\n\t@States({\r\n\t\t@State(name=\"NEW\"),\r\n\t\t@State(name=\"MOVE\", historyType=HistoryType.DEEP),\r\n\t\t@State(parent=\"MOVE\", name=\"UP\", initialState=true),\r\n\t\t@State(parent=\"MOVE\", name=\"LEFT\"),\r\n\t\t@State(parent=\"MOVE\", name=\"RIGHT\"),\r\n\t\t@State(parent=\"MOVE\", name=\"DOWN\"),\r\n\t\t@State(name=\"PAUSE\"),\r\n\t\t@State(name=\"GAMEOVER\")\r\n\t})\r\n\t@Transitions({\r\n\t\t@Transit(from=\"NEW\", to=\"MOVE\", on=\"PRESS_START\", callMethod=\"onStart\"),\r\n    \t@Transit(from = \"GAMEOVER\", to = \"MOVE\", on = \"PRESS_START\", callMethod = \"onStart\"),\r\n    \t@Transit(from = \"MOVE\", to = \"GAMEOVER\", on = \"MOVE_AHEAD\", callMethod = \"onEnd\"),\r\n    \t@Transit(from = \"MOVE\", to = \"GAMEOVER\", on = \"BODY_COLLAPSED\", callMethod = \"onEnd\"),\r\n    \t@Transit(from = \"UP\", to = \"UP\", on = \"MOVE_AHEAD\", callMethod = \"onMove\", type = TransitionType.INTERNAL, when = SnakeController.InBorderCondition.class),\r\n    \t@Transit(from = \"DOWN\", to = \"DOWN\", on = \"MOVE_AHEAD\", callMethod = \"onMove\", type = TransitionType.INTERNAL, when = SnakeController.InBorderCondition.class),\r\n    \t@Transit(from = \"LEFT\", to = \"LEFT\", on = \"MOVE_AHEAD\", callMethod = \"onMove\", type = TransitionType.INTERNAL, when = SnakeController.InBorderCondition.class),\r\n    \t@Transit(from = \"RIGHT\", to = \"RIGHT\", on = \"MOVE_AHEAD\", callMethod = \"onMove\", type = TransitionType.INTERNAL, when = SnakeController.InBorderCondition.class),\r\n\t\t@Transit(from=\"MOVE\", to=\"PAUSE\", on=\"PRESS_PAUSE\", callMethod=\"onPause\"),\r\n\t\t@Transit(from=\"PAUSE\", to=\"MOVE\", on=\"PRESS_PAUSE\", callMethod=\"onResume\"),\r\n\t\t@Transit(from=\"UP\", to=\"LEFT\", on=\"TURN_LEFT\", callMethod=\"onChangeDirection\"),\r\n\t\t@Transit(from=\"UP\", to=\"RIGHT\", on=\"TURN_RIGHT\", callMethod=\"onChangeDirection\"),\r\n\t\t@Transit(from=\"DOWN\", to=\"LEFT\", on=\"TURN_LEFT\", callMethod=\"onChangeDirection\"),\r\n\t\t@Transit(from=\"DOWN\", to=\"RIGHT\", on=\"TURN_RIGHT\", callMethod=\"onChangeDirection\"),\r\n\t\t@Transit(from=\"LEFT\", to=\"UP\", on=\"TURN_UP\", callMethod=\"onChangeDirection\"),\r\n\t\t@Transit(from=\"LEFT\", to=\"DOWN\", on=\"TURN_DOWN\", callMethod=\"onChangeDirection\"),\r\n\t\t@Transit(from=\"RIGHT\", to=\"UP\", on=\"TURN_UP\", callMethod=\"onChangeDirection\"),\r\n\t\t@Transit(from=\"RIGHT\", to=\"DOWN\", on=\"TURN_DOWN\", callMethod=\"onChangeDirection\")\r\n\t})\r\n\tpublic class SnakeController extends AbstractStateMachine<SnakeController, SnakeState, SnakeEvent, SnakeContext> {\r\n\t...\r\n\t}\r\n\t```\r\n\tThis example can be found in package *\"org.squirrelframework.foundation.fsm.snake\"*. \r\n### Integration Exmaples\r\nSquirrel state machine does not have any heavy dependencies, so basically it should be highly embedable.\r\n* **Spring Framework Integration**  \r\nTo Integrate with Spring IoC container, basically user can add @Configurable annotation on the state machine implementation class, e.g.\r\n```java\r\n\tinterface StateMachineBean extends StateMachine<StateMachineBean, MyState, MyEvent, MyContext> {\r\n\t\t...\r\n\t}\r\n\r\n\t@Configurable(preConstruction=true)\r\n\tabstract class AbstractStateMachineBean extends AbstractStateMachine<StateMachineBean, MyState, \t\tMyEvent, MyContext> implements StateMachineBean {\r\n\t\t@Autowired\r\n  \t\tprivate ApplicationContext applicationContext;\r\n\t\t...\r\n\t}\r\n\t\r\n\tpublic class TypedStateMachineA extends AbstractStateMachineBean {\r\n  \t\t@Autowired\r\n  \t\t// some other managed beans...\r\n\t}\r\n\t\r\n\tpublic class TypedStateMachineB extends AbstractStateMachineBean {\r\n  \t\t@Autowired\r\n  \t\t// some other managed beans...\r\n\t}\r\n\t\r\n\tTypedStateMachineA fsmA = StateMachineBuilderFactory.create(TypedStateMachineA.class, \r\n\t\tMyState.class, MyEvent.class, MyContext.class).newStateMachine(MyState.Initial);\r\n\tTypedStateMachineA fsmB = StateMachineBuilderFactory.create(TypedStateMachineB.class, \r\n\t\tMyState.class, MyEvent.class, MyContext.class).newStateMachine(MyState.Initial);\r\n```  \r\n\r\n## Release Notes  \r\n*Version 0.2.2.5 - 2013-12-26*  \r\n1. Support prioritized transition  \r\n2. Provide thread-safe implementation of StateMachine  \r\n3. Update current states of state machine after actions all executed successfully  \r\n4. **Support transition condition and action defined in MVEL script**  \r\n5. **Breaking Change**: Add name() to Condition interface  \r\n6. **Add UntypedStateMachine to simplify usage**  \r\n7. Support build method call action through transition builder API  \r\n8. Add debug log when method call cannot find  \r\n9. **Support add declarative event listener**  \r\n10. Add **StateMachineLogger** to easy monitor state machine execution status  \r\n11. Update documentation\r\n\r\n*Version 0.2.1 - 2013-08-10*  \r\n1. Support test State machine transition result  \r\n2. Add *StateMachineWithoutContext* class to simplify state machine usage without need of context  \r\n3. Bug fixed for state machine data dump\r\n\r\n*Version 0.1.10 - 2013-07-13*  \r\n1. Support save/load state machine data\r\n  \r\n*Version 0.1.9  - 2013-07-01*  \r\n1. Add to *StateMachineBuilderFactory* simplify StateMachineBuilder creation  \r\n2. Deprecate StateMachineBuilderImpl.newStateMachineBuilder(...) methods\r\n \r\n*Version 0.1.8  - 2013-06-08*  \r\n1. Support **linked state** which also called substatemachine state  \r\n2. Rename addListener/removeListener of StateMachine to more specific name add\\*Listener/remove\\*Listener  \r\n3. Simplify converter registration for String and Enumeration type  \r\n\r\n## Future Plan  \r\n* State machine import  \r\n* Support both synchronized and asynchronized event dispatcher   \r\n* Support dynamic extend state machine definition  \r\n\r\n## More Information  \r\n* For the **latest updates** follow [@hhe11][5]\r\n* For discussions or questions please join the [squirrel state machine group][4]\r\n* For any issue or requirement, please submit an [issue][6]\r\n\r\n[1]: http://en.wikipedia.org/wiki/UML_state_machine\r\n[2]: http://www.w3.org/TR/scxml/\r\n[3]: http://www.graphviz.org/\r\n[4]: http://groups.google.com/group/squirrel-state-machine\r\n[5]: https://twitter.com/hhe11\r\n[6]: https://github.com/hekailiang/squirrel/issues?state=open\r\n[7]: http://mvel.codehaus.org/\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}