<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Squirrel State Machine by hekailiang</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css">
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>
      <div id="header">
        <nav>
          <li class="fork"><a href="https://github.com/hekailiang/squirrel">View On GitHub</a></li>
          <li class="downloads"><a href="https://github.com/hekailiang/squirrel/zipball/master">ZIP</a></li>
          <li class="downloads"><a href="https://github.com/hekailiang/squirrel/tarball/master">TAR</a></li>
          <li class="title">DOWNLOADS</li>
        </nav>
      </div><!-- end header -->

    <div class="wrapper">

      <section>
        <div id="title">
          <h1>Squirrel State Machine</h1>
          <p>squirrel-foundation provided an easy use, type safe and highly extensible state machine implementation for Java.</p>
          <hr>
          <span class="credits left">Project maintained by <a href="https://github.com/hekailiang">hekailiang</a></span>
          <span class="credits right">Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></span>
        </div>

        <h1>
<a id="squirrel-foundation--" class="anchor" href="#squirrel-foundation--" aria-hidden="true"><span class="octicon octicon-link"></span></a>squirrel-foundation  </h1>

<h2>
<a id="what-is-it" class="anchor" href="#what-is-it" aria-hidden="true"><span class="octicon octicon-link"></span></a>What is it?</h2>

<p>Just like the squirrel, a <strong>small</strong>, <strong>agile</strong>, <strong>smart</strong>, <strong>alert</strong> and <strong>cute</strong> animal, squirrel-foundation is aimed to provide a <strong>lightweight</strong>, highly <strong>flexible</strong> and <strong>extensible</strong>, <strong>diagnosable</strong>, <strong>easy use</strong> and <strong>type safe</strong> Java state machine implementation for enterprise usage.  </p>

<p>Here is the state machine diagram which describes the state change of an ATM:  </p>

<p><img src="http://hekailiang.github.io/squirrel/images/ATMStateMachine.png" alt="ATMStateMachine"><br>
The sample code could be found in package <em>"org.squirrelframework.foundation.fsm.atm"</em>.</p>

<h2>
<a id="maven" class="anchor" href="#maven" aria-hidden="true"><span class="octicon octicon-link"></span></a>Maven</h2>

<p>squirrel-foundation has been deployed to maven central repository, so you only need to add following  dependency to the pom.xml.</p>

<p>Latest Released Version:</p>

<pre lang="maven"><code>&lt;dependency&gt;
    &lt;groupId&gt;org.squirrelframework&lt;/groupId&gt;
    &lt;artifactId&gt;squirrel-foundation&lt;/artifactId&gt;
    &lt;version&gt;0.3.5&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p>Latest Snapshot Version:  </p>

<pre lang="maven"><code>&lt;dependency&gt;
    &lt;groupId&gt;org.squirrelframework&lt;/groupId&gt;
    &lt;artifactId&gt;squirrel-foundation&lt;/artifactId&gt;
    &lt;version&gt;0.3.6-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<h2>
<a id="quick-start" class="anchor" href="#quick-start" aria-hidden="true"><span class="octicon octicon-link"></span></a>Quick Start</h2>

<p>To quickly try squirrel state machine functions, please create a maven project and include squirrel-foundation dependency properly. Then just run following sample code.  </p>

<div class="highlight highlight-java"><pre><span class="pl-s">public</span> <span class="pl-s">class</span> <span class="pl-en">QuickStartSample</span> {

    <span class="pl-c">// 1. Define State Machine Event</span>
    <span class="pl-s">enum</span> <span class="pl-en">FSMEvent</span> {
        <span class="pl-stj">ToA</span>, <span class="pl-stj">ToB</span>, <span class="pl-stj">ToC</span>, <span class="pl-stj">ToD</span>
    }

    <span class="pl-c">// 2. Define State Machine Class</span>
    <span class="pl-st">@StateMachineParameters</span>(<span class="pl-c1">stateType</span><span class="pl-k">=</span><span class="pl-stj">String</span><span class="pl-k">.</span>class, <span class="pl-c1">eventType</span><span class="pl-k">=</span><span class="pl-stj">FSMEvent</span><span class="pl-k">.</span>class, <span class="pl-c1">contextType</span><span class="pl-k">=</span><span class="pl-stj">Integer</span><span class="pl-k">.</span>class)
    <span class="pl-s">static</span> <span class="pl-s">class</span> <span class="pl-en">StateMachineSample</span> <span class="pl-s">extends</span> <span class="pl-e">AbstractUntypedStateMachine</span> {
        <span class="pl-s">protected</span> <span class="pl-st">void</span> <span class="pl-en">fromAToB</span>(<span class="pl-stj">String</span> <span class="pl-v">from</span>, <span class="pl-stj">String</span> <span class="pl-v">to</span>, <span class="pl-stj">FSMEvent</span> <span class="pl-v">event</span>, <span class="pl-stj">Integer</span> <span class="pl-v">context</span>) {
            <span class="pl-stj">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s1"><span class="pl-pds">"</span>Transition from '<span class="pl-pds">"</span></span><span class="pl-k">+</span>from<span class="pl-k">+</span><span class="pl-s1"><span class="pl-pds">"</span>' to '<span class="pl-pds">"</span></span><span class="pl-k">+</span>to<span class="pl-k">+</span><span class="pl-s1"><span class="pl-pds">"</span>' on event '<span class="pl-pds">"</span></span><span class="pl-k">+</span>event<span class="pl-k">+</span>
                <span class="pl-s1"><span class="pl-pds">"</span>' with context '<span class="pl-pds">"</span></span><span class="pl-k">+</span>context<span class="pl-k">+</span><span class="pl-s1"><span class="pl-pds">"</span>'.<span class="pl-pds">"</span></span>);
        }

        <span class="pl-s">protected</span> <span class="pl-st">void</span> <span class="pl-en">ontoB</span>(<span class="pl-stj">String</span> <span class="pl-v">from</span>, <span class="pl-stj">String</span> <span class="pl-v">to</span>, <span class="pl-stj">FSMEvent</span> <span class="pl-v">event</span>, <span class="pl-stj">Integer</span> <span class="pl-v">context</span>) {
            <span class="pl-stj">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s1"><span class="pl-pds">"</span>Entry State <span class="pl-cce">\'</span><span class="pl-pds">"</span></span><span class="pl-k">+</span>to<span class="pl-k">+</span><span class="pl-s1"><span class="pl-pds">"</span><span class="pl-cce">\'</span>.<span class="pl-pds">"</span></span>);
        }
    }

    <span class="pl-s">public</span> <span class="pl-s">static</span> <span class="pl-st">void</span> <span class="pl-en">main</span>(<span class="pl-st">String</span>[] <span class="pl-v">args</span>) {
        <span class="pl-c">// 3. Build State Transitions</span>
        <span class="pl-stj">UntypedStateMachineBuilder</span> builder <span class="pl-k">=</span> <span class="pl-stj">StateMachineBuilderFactory</span><span class="pl-k">.</span>create(<span class="pl-stj">StateMachineSample</span><span class="pl-k">.</span>class);
        builder<span class="pl-k">.</span>externalTransition()<span class="pl-k">.</span>from(<span class="pl-s1"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>to(<span class="pl-s1"><span class="pl-pds">"</span>B<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>on(<span class="pl-stj">FSMEvent</span><span class="pl-k">.</span><span class="pl-stj">ToB</span>)<span class="pl-k">.</span>callMethod(<span class="pl-s1"><span class="pl-pds">"</span>fromAToB<span class="pl-pds">"</span></span>);
        builder<span class="pl-k">.</span>onEntry(<span class="pl-s1"><span class="pl-pds">"</span>B<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>callMethod(<span class="pl-s1"><span class="pl-pds">"</span>ontoB<span class="pl-pds">"</span></span>);

        <span class="pl-c">// 4. Use State Machine</span>
        <span class="pl-stj">UntypedStateMachine</span> fsm <span class="pl-k">=</span> builder<span class="pl-k">.</span>newStateMachine(<span class="pl-s1"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span>);
        fsm<span class="pl-k">.</span>fire(<span class="pl-stj">FSMEvent</span><span class="pl-k">.</span><span class="pl-stj">ToB</span>, <span class="pl-c1">10</span>);

        <span class="pl-stj">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s1"><span class="pl-pds">"</span>Current state is <span class="pl-pds">"</span></span><span class="pl-k">+</span>fsm<span class="pl-k">.</span>getCurrentState());
    }
}
</pre></div>

<p>At now you may have many questions about the sample code, please be patient. The following user guide will answer most of your questions. But before getting into the details, it requires you have basic understanding on state machine concepts. These materials are good for understanding state machine concepts. <a href="http://www.uml-diagrams.org/state-machine-diagrams.html">[state-machine-diagrams]</a> <a href="http://qt-project.org/doc/qt-4.8/statemachine-api.html">[qt-state-machine]</a>  </p>

<h2>
<a id="user-guide" class="anchor" href="#user-guide" aria-hidden="true"><span class="octicon octicon-link"></span></a>User Guide</h2>

<h3>
<a id="get-starting" class="anchor" href="#get-starting" aria-hidden="true"><span class="octicon octicon-link"></span></a>Get Starting</h3>

<p><strong>squirrel-foundation</strong> supports both fluent API and declarative manner to declare a state machine, and also enable user to define the action methods in a straightforward manner. </p>

<ul>
<li>
<p><strong>StateMachine</strong> interface takes four generic type parameters.  </p>

<ul>
<li>
<strong>T</strong> stands for the type of implemented state machine.</li>
<li>
<strong>S</strong> stands for the type of implemented state.</li>
<li>
<strong>E</strong> stands for the type of implemented event.</li>
<li>
<strong>C</strong> stands for the type of implemented external context.</li>
</ul>
</li>
<li>
<p><strong>State Machine Builder</strong>  </p>

<ul>
<li>State machine builder is used to generate state machine definition. StateMachineBuilder can be created by StateMachineBuilderFactory.<br>
</li>
<li>The StateMachineBuilder is composed of *TransitionBuilder (InternalTransitionBuilder / LocalTransitionBuilder / ExternalTransitionBuilder) which is used to build transition between states, and EntryExitActionBuilder which is used to build the actions during entry or exit state. </li>
<li>The internal state is implicitly built during transition creation or state action creation.<br>
</li>
<li>All the state machine instances created by the same state machine builder share the same definition data for memory usage optimize.</li>
<li>State machine builder generate state machine definition in a lazy manner. When builder create first state machine instance, the state machine definition will be generated which is time consumed. But after state machine definition generated, the following state machine instance creation will be much faster. Generally, state machine builder should be reused as much as possible.</li>
</ul>

<p>In order to create a state machine, user need to create state machine builder first. For example:   </p>

<div class="highlight highlight-java"><pre><span class="pl-st">StateMachineBuilder&lt;<span class="pl-stj">MyStateMachine</span>, <span class="pl-stj">MyState</span>, <span class="pl-stj">MyEvent</span>, <span class="pl-stj">MyContext</span>&gt;</span> builder <span class="pl-k">=</span>
    <span class="pl-stj">StateMachineBuilderFactory</span><span class="pl-k">.</span>create(<span class="pl-stj">MyStateMachine</span><span class="pl-k">.</span>class, <span class="pl-stj">MyState</span><span class="pl-k">.</span>class, <span class="pl-stj">MyEvent</span><span class="pl-k">.</span>class, <span class="pl-stj">MyContext</span><span class="pl-k">.</span>class);     </pre></div>

<p>The state machine builder takes for parameters which are type of state machine(T), state(S), event(E) and context(C).</p>
</li>
<li>
<p><strong>Fluent API</strong><br>
After state machine builder was created, we can use fluent API to define state/transition/action of the state machine.</p>

<div class="highlight highlight-java"><pre>builder<span class="pl-k">.</span>externalTransition()<span class="pl-k">.</span>from(<span class="pl-stj">MyState</span><span class="pl-k">.</span><span class="pl-stj">A</span>)<span class="pl-k">.</span>to(<span class="pl-stj">MyState</span><span class="pl-k">.</span><span class="pl-stj">B</span>)<span class="pl-k">.</span>on(<span class="pl-stj">MyEvent</span><span class="pl-k">.</span><span class="pl-stj">GoToB</span>);</pre></div>

<p>An <strong>external transition</strong> is built between state 'A' to state 'B' and triggered on received event 'GoToB'.</p>

<div class="highlight highlight-java"><pre>builder<span class="pl-k">.</span>internalTransition(<span class="pl-stj">TransitionPriority</span><span class="pl-c1"><span class="pl-k">.</span>HIGH</span>)<span class="pl-k">.</span>within(<span class="pl-stj">MyState</span><span class="pl-k">.</span><span class="pl-stj">A</span>)<span class="pl-k">.</span>on(<span class="pl-stj">MyEvent</span><span class="pl-k">.</span><span class="pl-stj">WithinA</span>)<span class="pl-k">.</span>perform(myAction);</pre></div>

<p>An <strong>internal transition</strong> with priority set to high is build inside state 'A' on event 'WithinA' perform 'myAction'. The internal transition means after transition complete, no state is exited or entered. The transition priority is used to override original transition when state machine extended.</p>

<div class="highlight highlight-java"><pre>builder<span class="pl-k">.</span>externalTransition()<span class="pl-k">.</span>from(<span class="pl-stj">MyState</span><span class="pl-k">.</span><span class="pl-stj">C</span>)<span class="pl-k">.</span>to(<span class="pl-stj">MyState</span><span class="pl-k">.</span><span class="pl-stj">D</span>)<span class="pl-k">.</span>on(<span class="pl-stj">MyEvent</span><span class="pl-k">.</span><span class="pl-stj">GoToD</span>)<span class="pl-k">.</span>when(
    <span class="pl-k">new</span> <span class="pl-st">Condition&lt;<span class="pl-stj">MyContext</span>&gt;</span>() {
        <span class="pl-st">@Override</span>
        <span class="pl-s">public</span> <span class="pl-st">boolean</span> <span class="pl-en">isSatisfied</span>(<span class="pl-stj">MyContext</span> <span class="pl-v">context</span>) {
            <span class="pl-k">return</span> context<span class="pl-k">!=</span><span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> context<span class="pl-k">.</span>getValue()<span class="pl-k">&gt;</span><span class="pl-c1">80</span>;
        }

        <span class="pl-st">@Override</span>
        <span class="pl-s">public</span> <span class="pl-stj">String</span> <span class="pl-en">name</span>() {
            <span class="pl-k">return</span> <span class="pl-s1"><span class="pl-pds">"</span>MyCondition<span class="pl-pds">"</span></span>;
        }
})<span class="pl-k">.</span>callMethod(<span class="pl-s1"><span class="pl-pds">"</span>myInternalTransitionCall<span class="pl-pds">"</span></span>);</pre></div>

<p>An <strong>conditional transition</strong> is built from state 'C' to state 'D' on event 'GoToD' when external context satisfied the condition restriction, then call action method "myInternalTransitionCall". User can also use <a href="http://mvel.codehaus.org/">MVEL</a>(a powerful expression language) to describe condition in the following way.  </p>

<div class="highlight highlight-java"><pre>builder<span class="pl-k">.</span>externalTransition()<span class="pl-k">.</span>from(<span class="pl-stj">MyState</span><span class="pl-k">.</span><span class="pl-stj">C</span>)<span class="pl-k">.</span>to(<span class="pl-stj">MyState</span><span class="pl-k">.</span><span class="pl-stj">D</span>)<span class="pl-k">.</span>on(<span class="pl-stj">MyEvent</span><span class="pl-k">.</span><span class="pl-stj">GoToD</span>)<span class="pl-k">.</span>whenMvel(
    <span class="pl-s1"><span class="pl-pds">"</span>MyCondition:::(context!=null &amp;&amp; context.getValue()&gt;80)<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>callMethod(<span class="pl-s1"><span class="pl-pds">"</span>myInternalTransitionCall<span class="pl-pds">"</span></span>);</pre></div>

<p><strong>Note:</strong> Characters ':::' use to separate condition name and condition expression. The 'context' is the predefined variable point to current Context object.    </p>

<div class="highlight highlight-java"><pre>builder<span class="pl-k">.</span>onEntry(<span class="pl-stj">MyState</span><span class="pl-k">.</span><span class="pl-stj">A</span>)<span class="pl-k">.</span>perform(<span class="pl-stj">Lists</span><span class="pl-k">.</span>newArrayList(action1, action2))</pre></div>

<p>A list of state entry actions is defined in above sample code.</p>
</li>
<li>
<p><strong>Method Call Action</strong><br>
User can define anonymous actions during define transitions or state entry/exit. However, the action code will be scattered over many places which may make code hard to maintain. Moreover, other user cannot override the actions. So squirrel-foundation also support to define state machine method call action which comes along with state machine class itself.   </p>

<div class="highlight highlight-java"><pre><span class="pl-st">StateMachineBuilder&lt;.</span><span class="pl-c1">..</span><span class="pl-k">&gt;</span> builder <span class="pl-k">=</span> <span class="pl-stj">StateMachineBuilderFactory</span><span class="pl-k">.</span>create(
    <span class="pl-stj">MyStateMachine</span><span class="pl-k">.</span>class, <span class="pl-stj">MyState</span><span class="pl-k">.</span>class, <span class="pl-stj">MyEvent</span><span class="pl-k">.</span>class, <span class="pl-stj">MyContext</span><span class="pl-k">.</span>class);
builder<span class="pl-k">.</span>externalTransition()<span class="pl-k">.</span>from(<span class="pl-stj">A</span>)<span class="pl-k">.</span>to(<span class="pl-stj">B</span>)<span class="pl-k">.</span>on(toB)<span class="pl-k">.</span>callMethod(<span class="pl-s1"><span class="pl-pds">"</span>fromAToB<span class="pl-pds">"</span></span>);

<span class="pl-c">// All transition action method stays with state machine class</span>
<span class="pl-s">public</span> <span class="pl-s">class</span> <span class="pl-en">MyStateMachine</span>&lt;...&gt; <span class="pl-s">extends</span> <span class="pl-e">AbstractStateMachine&lt;.</span>..&gt; {
    <span class="pl-s">protected</span> <span class="pl-st">void</span> <span class="pl-en">fromAToB</span>(<span class="pl-stj">MyState</span> <span class="pl-v">from</span>, <span class="pl-stj">MyState</span> <span class="pl-v">to</span>, <span class="pl-stj">MyEvent</span> <span class="pl-v">event</span>, <span class="pl-stj">MyContext</span> <span class="pl-v">context</span>) {
        <span class="pl-c">// this method will be called during transition from "A" to "B" on event "toB"</span>
        <span class="pl-c">// the action method parameters types and order should match</span>
        <span class="pl-c1">...</span>
    }
}</pre></div>

<p>Moreover, squirrel-foundation also support define method call actions in a <strong>Convention Over Configuration</strong> manner. Basically, this means that if the method declared in state machine satisfied naming and parameters convention, it will be added into the transition action list and also be invoked at certain phase. e.g.  </p>

<div class="highlight highlight-java"><pre><span class="pl-s">protected</span> <span class="pl-st">void</span> transitFromAToBOnGoToB(<span class="pl-stj">MyState</span> from, <span class="pl-stj">MyState</span> to, <span class="pl-stj">MyEvent</span> event, <span class="pl-stj">MyContext</span> context)</pre></div>

<p>The method named as <strong>transitFrom[SourceStateName]To[TargetStateName]On[EventName]</strong>, and parameterized as [MyState, MyState, MyEvent, MyContext] will be added into transition "A-(GoToB)-&gt;B" action list. When transiting from state 'A' to state 'B' on event 'GoToB', this method will be invoked.</p>

<div class="highlight highlight-java"><pre><span class="pl-s">protected</span> <span class="pl-st">void</span> transitFromAnyToBOnGoToB(<span class="pl-stj">MyState</span> from, <span class="pl-stj">MyState</span> to, <span class="pl-stj">MyEvent</span> event, <span class="pl-stj">MyContext</span> context)</pre></div>

<p><strong>transitFromAnyTo[TargetStateName]On[EventName]</strong> The method will be invoked when transit from any state to state 'B' on event 'GoToB'.</p>

<div class="highlight highlight-java"><pre><span class="pl-s">protected</span> <span class="pl-st">void</span> exitA(<span class="pl-stj">MyState</span> from, <span class="pl-stj">MyState</span> to, <span class="pl-stj">MyEvent</span> event, <span class="pl-stj">MyContext</span> context)</pre></div>

<p><strong>exit[StateName]</strong> The method will be invoked when exit state 'A'. So as the <strong>entry[StateName]</strong> , <strong>beforeExitAny</strong>/<strong>afterExitAny</strong> and <strong>beforeEntryAny</strong>/<strong>afterEntryAny</strong>.  </p>

<p><strong><em>Other Supported Naming Patterns:</em></strong></p>

<pre><code>transitFrom[fromStateName]To[toStateName]On[eventName]When[conditionName]  
transitFrom[fromStateName]To[toStateName]On[eventName]  
transitFromAnyTo[toStateName]On[eventName]  
transitFrom[fromStateName]ToAnyOn[eventName]  
transitFrom[fromStateName]To[toStateName]          
on[eventName] 
</code></pre>

<p>Those method conventions listed above also provided <strong>AOP-like</strong> functionalities, which provided build-in flexible extension capability for squirrel state machine at any granularity.<br>
For more information, please refer to test case "<em>org.squirrelframework.foundation.fsm.ExtensionMethodCallTest</em>".<br>
Since 0.3.1, there is another way to define these AOP-like extension methods which is through fluent API (thanks suggestion from <a href="https://github.com/vittali">vittali</a>), e.g.</p>

<div class="highlight highlight-java"><pre><span class="pl-c">// since 0.3.1</span>
<span class="pl-c">// the same effect as add method transitFromAnyToCOnToC in your state machine</span>
builder<span class="pl-k">.</span>transit()<span class="pl-k">.</span>fromAny()<span class="pl-k">.</span>to(<span class="pl-s1"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>on(<span class="pl-s1"><span class="pl-pds">"</span>ToC<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>callMethod(<span class="pl-s1"><span class="pl-pds">"</span>fromAnyToC<span class="pl-pds">"</span></span>);
<span class="pl-c">// the same effect as add method transitFromBToAnyOnToC in your state machine</span>
builder<span class="pl-k">.</span>transit()<span class="pl-k">.</span>from(<span class="pl-s1"><span class="pl-pds">"</span>B<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>toAny()<span class="pl-k">.</span>on(<span class="pl-s1"><span class="pl-pds">"</span>ToC<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>callMethod(<span class="pl-s1"><span class="pl-pds">"</span>fromBToAny<span class="pl-pds">"</span></span>);
<span class="pl-c">// the same effect as add method transitFromBToAny in your state machine</span>
builder<span class="pl-k">.</span>transit()<span class="pl-k">.</span>from(<span class="pl-s1"><span class="pl-pds">"</span>B<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>toAny()<span class="pl-k">.</span>onAny()<span class="pl-k">.</span>callMethod(<span class="pl-s1"><span class="pl-pds">"</span>fromBToAny<span class="pl-pds">"</span></span>);</pre></div>

<p>Or through declarative annotation, e.g.</p>

<div class="highlight highlight-java"><pre><span class="pl-c">// since 0.3.1</span>
@Transitions({
     @Transit(from<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>B<span class="pl-pds">"</span></span>, to<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>E<span class="pl-pds">"</span></span>, on<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>*<span class="pl-pds">"</span></span>,   callMethod<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>fromBToEOnAny<span class="pl-pds">"</span></span>),
     @Transit(from<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>*<span class="pl-pds">"</span></span>, to<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>E<span class="pl-pds">"</span></span>, on<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>ToE<span class="pl-pds">"</span></span>, callMethod<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>fromAnyToEOnToE<span class="pl-pds">"</span></span>)
})</pre></div>

<p><strong>Note</strong>: These action methods will be attached to <em>matched and already existed transitions</em> but not to create any new transitions.<br>
Since 0.3.4, multiple transitions can also be defined once at a time using following API, e.g.</p>

<div class="highlight highlight-java"><pre><span class="pl-c">// transitions(A-&gt;B@A2B=&gt;a2b, A-&gt;C@A2C=&gt;a2c, A-&gt;D@A2D) will be defined at once</span>
builder<span class="pl-k">.</span>transitions()<span class="pl-k">.</span>from(<span class="pl-stj">State</span><span class="pl-k">.</span>_A)<span class="pl-k">.</span>toAmong(<span class="pl-stj">State</span><span class="pl-k">.</span><span class="pl-stj">B</span>, <span class="pl-stj">State</span><span class="pl-k">.</span><span class="pl-stj">C</span>, <span class="pl-stj">State</span><span class="pl-k">.</span><span class="pl-stj">D</span>)<span class="pl-c1">.</span>
        onEach(<span class="pl-stj">Event</span><span class="pl-c1"><span class="pl-k">.</span>A2B</span>, <span class="pl-stj">Event</span><span class="pl-c1"><span class="pl-k">.</span>A2C</span>, <span class="pl-stj">Event</span><span class="pl-c1"><span class="pl-k">.</span>A2D</span>)<span class="pl-k">.</span>callMethod(<span class="pl-s1"><span class="pl-pds">"</span>a2b|a2c|_<span class="pl-pds">"</span></span>);

<span class="pl-c">// transitions(A-&gt;_A@A2ANY=&gt;DecisionMaker, _A-&gt;A@ANY2A) will be defined at once</span>
builder<span class="pl-k">.</span>localTransitions()<span class="pl-k">.</span>between(<span class="pl-stj">State</span><span class="pl-k">.</span><span class="pl-stj">A</span>)<span class="pl-k">.</span>and(<span class="pl-stj">State</span><span class="pl-k">.</span>_A)<span class="pl-c1">.</span>
        onMutual(<span class="pl-stj">Event</span><span class="pl-c1"><span class="pl-k">.</span>A2ANY</span>, <span class="pl-stj">Event</span><span class="pl-c1"><span class="pl-k">.</span>ANY2A</span>)<span class="pl-c1">.</span>
        perform( <span class="pl-stj">Lists</span><span class="pl-k">.</span>newArrayList(<span class="pl-k">new</span> <span class="pl-stj">DecisionMaker</span>(<span class="pl-s1"><span class="pl-pds">"</span>SomeLocalState<span class="pl-pds">"</span></span>), <span class="pl-c1">null</span>) );</pre></div>

<p>More information can be found in <em>org.squirrelframework.foundation.fsm.samples.DecisionStateSampleTest</em>;</p>
</li>
<li>
<p><strong>Declarative Annotation</strong><br>
A declarative way is also provided to define and also to extend the state machine. Here is an example.  </p>

<div class="highlight highlight-java"><pre>@States({
    @State(name<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span>, entryCallMethod<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>entryStateA<span class="pl-pds">"</span></span>, exitCallMethod<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>exitStateA<span class="pl-pds">"</span></span>), 
    @State(name<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>B<span class="pl-pds">"</span></span>, entryCallMethod<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>entryStateB<span class="pl-pds">"</span></span>, exitCallMethod<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>exitStateB<span class="pl-pds">"</span></span>)
})
@Transitions({
    @Transit(from<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span>, to<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>B<span class="pl-pds">"</span></span>, on<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>GoToB<span class="pl-pds">"</span></span>, callMethod<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>stateAToStateBOnGotoB<span class="pl-pds">"</span></span>),
    @Transit(from<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span>, to<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span>, on<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>WithinA<span class="pl-pds">"</span></span>, callMethod<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>stateAToStateAOnWithinA<span class="pl-pds">"</span></span>, type<span class="pl-k">=</span><span class="pl-stj">TransitionType</span><span class="pl-c1"><span class="pl-k">.</span>INTERNAL</span>)
})
<span class="pl-s">interface</span> <span class="pl-en">MyStateMachine</span> <span class="pl-s">extends</span> <span class="pl-e">StateMachine&lt;<span class="pl-stj">MyStateMachine</span>, <span class="pl-stj">MyState</span>, <span class="pl-stj">MyEvent</span>, <span class="pl-stj">MyContext</span>&gt;</span> {
    <span class="pl-st">void</span> <span class="pl-en">entryStateA</span>(<span class="pl-stj">MyState</span> <span class="pl-v">from</span>, <span class="pl-stj">MyState</span> <span class="pl-v">to</span>, <span class="pl-stj">MyEvent</span> <span class="pl-v">event</span>, <span class="pl-stj">MyContext</span> <span class="pl-v">context</span>);
    <span class="pl-st">void</span> <span class="pl-en">stateAToStateBOnGotoB</span>(<span class="pl-stj">MyState</span> <span class="pl-v">from</span>, <span class="pl-stj">MyState</span> <span class="pl-v">to</span>, <span class="pl-stj">MyEvent</span> <span class="pl-v">event</span>, <span class="pl-stj">MyContext</span> <span class="pl-v">context</span>)
    <span class="pl-st">void</span> <span class="pl-en">stateAToStateAOnWithinA</span>(<span class="pl-stj">MyState</span> <span class="pl-v">from</span>, <span class="pl-stj">MyState</span> <span class="pl-v">to</span>, <span class="pl-stj">MyEvent</span> <span class="pl-v">event</span>, <span class="pl-stj">MyContext</span> <span class="pl-v">context</span>)
    <span class="pl-st">void</span> <span class="pl-en">exitStateA</span>(<span class="pl-stj">MyState</span> <span class="pl-v">from</span>, <span class="pl-stj">MyState</span> <span class="pl-v">to</span>, <span class="pl-stj">MyEvent</span> <span class="pl-v">event</span>, <span class="pl-stj">MyContext</span> <span class="pl-v">context</span>);
    <span class="pl-c1">...</span>
}</pre></div>

<p>The annotation can be defined in both implementation class of state machine or any interface that state machine will be implemented. It also can be used mixed with fluent API, which means the state machine defined in fluent API can also be extended by these annotations. (One thing you may need to be noticed, the method defined within interface must be public, which means also the method call action implementation will be public to caller.)  </p>
</li>
<li>
<p><strong>Converters</strong><br>
In order to declare state and event within <em><a href="https://github.com/State" class="user-mention">@State</a></em> and <em><a href="https://github.com/Transit" class="user-mention">@Transit</a></em>, user need to implement corresponding converters for their state(S) and event(E) type. The convert must implement Converter&lt;T&gt; interface, which convert the state/event to/from String.</p>

<div class="highlight highlight-java"><pre><span class="pl-s">public</span> <span class="pl-s">interface</span> <span class="pl-en">Converter</span>&lt;T&gt; <span class="pl-s">extends</span> <span class="pl-e">SquirrelComponent</span> {
    <span class="pl-c">/**</span>
<span class="pl-c">    * Convert object to string.</span>
<span class="pl-c">    * <span class="pl-k">@param</span> obj converted object</span>
<span class="pl-c">    * <span class="pl-k">@return</span> string description of object</span>
<span class="pl-c">    */</span>
    <span class="pl-stj">String</span> <span class="pl-en">convertToString</span>(<span class="pl-stj">T</span> <span class="pl-v">obj</span>);

    <span class="pl-c">/**</span>
<span class="pl-c">    * Convert string to object.</span>
<span class="pl-c">    * <span class="pl-k">@param</span> name name of the object</span>
<span class="pl-c">    * <span class="pl-k">@return</span> converted object</span>
<span class="pl-c">    */</span>
    <span class="pl-stj">T</span> <span class="pl-en">convertFromString</span>(<span class="pl-stj">String</span> <span class="pl-v">name</span>);
}</pre></div>

<p>Then register these converters to <em>ConverterProvider</em>. e.g.</p>

<div class="highlight highlight-java"><pre><span class="pl-stj">ConverterProvider</span><span class="pl-c1"><span class="pl-k">.</span>INSTANCE</span><span class="pl-k">.</span>register(<span class="pl-stj">MyEvent</span><span class="pl-k">.</span>class, <span class="pl-k">new</span> <span class="pl-stj">MyEventConverter</span>());
<span class="pl-stj">ConverterProvider</span><span class="pl-c1"><span class="pl-k">.</span>INSTANCE</span><span class="pl-k">.</span>register(<span class="pl-stj">MyState</span><span class="pl-k">.</span>class, <span class="pl-k">new</span> <span class="pl-stj">MyStateConverter</span>());</pre></div>

<p><em>Note: If you only use fluent API to define state machine, there is no need to implement corresponding converters. And also if the Event or State class is type of String or Enumeration, you don't need to implement or register a converter explicitly at most of cases.</em></p>
</li>
<li>
<p><strong>New State Machine Instance</strong><br>
After user defined state machine behaviour, user could create a new state machine instance through builder. Note, once the state machine instance is created from the builder, the builder cannot used to define any new element of state machine anymore.</p>

<div class="highlight highlight-java"><pre><span class="pl-stj">T</span> newStateMachine(<span class="pl-stj">S</span> initialStateId, <span class="pl-stj">Object</span><span class="pl-k">.</span><span class="pl-c1">..</span> extraParams);</pre></div>

<p>To create a new state machine instance from state machine builder, you need to pass following parameters.</p>

<ol>
<li>
<code>initialStateId</code>: When started, the initial state of the state machine.</li>
<li>
<p><code>extraParams</code>: Extra parameters that needed for create new state machine instance. Set to <em>"new Object[0]"</em> for no extra parameters needed.  </p>

<p>a. If user passed extra parameters while creating a new state machine instance, please be sure that StateMachineBuilderFactory also had defined type of extra parameters when creating the state machine builder. Otherwise, extra parameter will be ignored.<br>
b. Extra parameters can be passed into state machine instance in two ways. One is through state machine constructor which means user need to define a constructor with the same parameters' type and order for the state machine instance. Another way is define a method named <code>postConstruct</code> and also with the same parameters' type and order.          </p>
</li>
</ol>

<p>If no extra parameters need to passed to state machine, user can simply call <code>T newStateMachine(S initialStateId)</code> to create a new state machine instance.  </p>

<p>New state machine from state machine builder. (In this case, no extra parameters need to be passed.)</p>

<div class="highlight highlight-java"><pre><span class="pl-stj">MyStateMachine</span> stateMachine <span class="pl-k">=</span> builder<span class="pl-k">.</span>newStateMachine(<span class="pl-stj">MyState</span><span class="pl-k">.</span><span class="pl-stj">Initial</span>);</pre></div>
</li>
<li>
<p><strong>Trigger Transitions</strong><br>
After state machine was created, user can fire events along with context to trigger transition inside state machine. e.g.</p>

<div class="highlight highlight-java"><pre>stateMachine<span class="pl-k">.</span>fire(<span class="pl-stj">MyEvent</span><span class="pl-k">.</span><span class="pl-stj">Prepare</span>, <span class="pl-k">new</span> <span class="pl-stj">MyContext</span>(<span class="pl-s1"><span class="pl-pds">"</span>Testing<span class="pl-pds">"</span></span>));   </pre></div>
</li>
<li>
<p><strong>Untyped State Machine</strong><br>
In order to simplify state machine usage, and avoid too many generic types (e.g. StateMachine&lt;T, S, E, C&gt;) which may make code hard to read in some case, but still keep important part of type safety feature on transition action execution, UntypedStateMachine was implemented for this purpose.</p>

<div class="highlight highlight-java"><pre><span class="pl-s">enum</span> <span class="pl-en">TestEvent</span> {
    toA, toB, toC, toD
}

@Transitions({
    @Transit(from<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span>, to<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>B<span class="pl-pds">"</span></span>, on<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>toB<span class="pl-pds">"</span></span>, callMethod<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>fromAToB<span class="pl-pds">"</span></span>),
    @Transit(from<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>B<span class="pl-pds">"</span></span>, to<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span>, on<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>toC<span class="pl-pds">"</span></span>),
    @Transit(from<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span>, to<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>D<span class="pl-pds">"</span></span>, on<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>toD<span class="pl-pds">"</span></span>)
})
@StateMachineParameters(stateType<span class="pl-k">=</span><span class="pl-stj">String</span><span class="pl-k">.</span>class, eventType<span class="pl-k">=</span><span class="pl-stj">TestEvent</span><span class="pl-k">.</span>class, contextType<span class="pl-k">=</span><span class="pl-stj">Integer</span><span class="pl-k">.</span>class)
<span class="pl-s">class</span> <span class="pl-en">UntypedStateMachineSample</span> <span class="pl-s">extends</span> <span class="pl-e">AbstractUntypedStateMachine</span> {
    <span class="pl-c">// No need to specify constructor anymore since 0.2.9  </span>
    <span class="pl-c">// protected UntypedStateMachineSample(ImmutableUntypedState initialState, </span>
    <span class="pl-c">//  Map&lt;Object, ImmutableUntypedState&gt; states) {</span>
    <span class="pl-c">//    super(initialState, states);</span>
    <span class="pl-c">// }</span>

    <span class="pl-s">protected</span> <span class="pl-st">void</span> <span class="pl-en">fromAToB</span>(<span class="pl-stj">String</span> <span class="pl-v">from</span>, <span class="pl-stj">String</span> <span class="pl-v">to</span>, <span class="pl-stj">TestEvent</span> <span class="pl-v">event</span>, <span class="pl-stj">Integer</span> <span class="pl-v">context</span>) {
        <span class="pl-c">// transition action still type safe ...</span>
    }

    <span class="pl-s">protected</span> <span class="pl-st">void</span> <span class="pl-en">transitFromDToAOntoA</span>(<span class="pl-stj">String</span> <span class="pl-v">from</span>, <span class="pl-stj">String</span> <span class="pl-v">to</span>, <span class="pl-stj">TestEvent</span> <span class="pl-v">event</span>, <span class="pl-stj">Integer</span> <span class="pl-v">context</span>) {
        <span class="pl-c">// transition action still type safe ...</span>
    }
}

<span class="pl-stj">UntypedStateMachineBuilder</span> builder <span class="pl-k">=</span> <span class="pl-stj">StateMachineBuilderFactory</span><span class="pl-k">.</span>create(
    <span class="pl-stj">UntypedStateMachineSample</span><span class="pl-k">.</span>class);
<span class="pl-c">// state machine builder not type safe anymore</span>
builder<span class="pl-k">.</span>externalTransition()<span class="pl-k">.</span>from(<span class="pl-s1"><span class="pl-pds">"</span>D<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>to(<span class="pl-s1"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>on(<span class="pl-stj">TestEvent</span><span class="pl-k">.</span>toA);
<span class="pl-stj">UntypedStateMachine</span> fsm <span class="pl-k">=</span> builder<span class="pl-k">.</span>newStateMachine(<span class="pl-s1"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span>);</pre></div>

<p>To build an UntypedStateMachine, user need to create an UntypedStateMachineBuilder through StateMachineBuilderFactory first. StateMachineBuilderFactory takes only one parameter which is type of state machine class to create UntypedStateMachineBuilder. <em>@StateMachineParameters</em> is used to declare state machine generic parameter types. <em>AbstractUntypedStateMachine</em> is the base class of any untyped state machine.  </p>
</li>
<li>
<p><strong>Context Insensitive State Machine</strong><br>
Sometimes state transition does not care about context, which means transition mostly only determined by event. For this case user can use context insensitive state machine to simplify method call parameters.<br>
To declare context insensitive state machine is quite simple. User only need to add annotation <em>@ContextInsensitive</em> on state machine implementation class. After that, context parameter can be ignored on the transition method parameter list. e.g.  </p>

<div class="highlight highlight-java"><pre>@<span class="pl-stj">ContextInsensitive</span>
<span class="pl-s">public</span> <span class="pl-s">class</span> <span class="pl-en">ATMStateMachine</span> <span class="pl-s">extends</span> <span class="pl-e">AbstractStateMachine&lt;<span class="pl-stj">ATMStateMachine</span>, <span class="pl-stj">ATMState</span>, <span class="pl-stj">String</span>, <span class="pl-stj">Void</span>&gt;</span> {
    <span class="pl-c">// no need to add context parameter here anymore</span>
    <span class="pl-s">public</span> <span class="pl-st">void</span> <span class="pl-en">transitFromIdleToLoadingOnConnected</span>(<span class="pl-stj">ATMState</span> <span class="pl-v">from</span>, <span class="pl-stj">ATMState</span> <span class="pl-v">to</span>, <span class="pl-stj">String</span> <span class="pl-v">event</span>) {
        <span class="pl-c1">...</span>
    }
    <span class="pl-s">public</span> <span class="pl-st">void</span> <span class="pl-en">entryLoading</span>(<span class="pl-stj">ATMState</span> <span class="pl-v">from</span>, <span class="pl-stj">ATMState</span> <span class="pl-v">to</span>, <span class="pl-stj">String</span> <span class="pl-v">event</span>) {
        <span class="pl-c1">...</span>
    }
}</pre></div>
</li>
<li>
<p><strong>Transition Exception Handling</strong><br>
When exception happened during state transition, the executed action list will be aborted and state machine will be enter error status, which means the state machine instance cannot process event anymore. If user continue to fire event to the state machine instance, a IllegalStateException will be thrown out.<br>
All the exception happened during transition phase including action execution and external listener invocation will be wrapped into TransitionException(unchecked exception). Currently, the default exception handling strategy is simple and rude by just continuing throw out the exception, see AbstractStateMachine.afterTransitionCausedException method.  </p>

<div class="highlight highlight-java"><pre><span class="pl-s">protected</span> <span class="pl-st">void</span> afterTransitionCausedException(<span class="pl-c1">...</span>) { <span class="pl-k">throw</span> e; }</pre></div>

<p>If state machine can be recovered from this exception, user can extend afterTransitionCausedException method, and add corresponding the recovery logic in this method. <strong>DONOT</strong> forget to set state machine status back to normal at the end. e.g.  </p>

<div class="highlight highlight-java"><pre>@<span class="pl-stj">Override</span>
<span class="pl-s">protected</span> <span class="pl-st">void</span> afterTransitionCausedException(<span class="pl-stj">Object</span> fromState, <span class="pl-stj">Object</span> toState, <span class="pl-stj">Object</span> event, <span class="pl-stj">Object</span> context) {
    <span class="pl-stj">Throwable</span> targeException <span class="pl-k">=</span> getLastException()<span class="pl-k">.</span>getTargetException();
    <span class="pl-c">// recover from IllegalArgumentException thrown out from state 'A' to 'B' caused by event 'ToB'</span>
    <span class="pl-k">if</span>(targeException <span class="pl-k">instanceof</span> <span class="pl-stj">IllegalArgumentException</span> <span class="pl-k">&amp;&amp;</span> 
            fromState<span class="pl-k">.</span>equals(<span class="pl-s1"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span>) <span class="pl-k">&amp;&amp;</span> toState<span class="pl-k">.</span>equals(<span class="pl-s1"><span class="pl-pds">"</span>B<span class="pl-pds">"</span></span>) <span class="pl-k">&amp;&amp;</span> event<span class="pl-k">.</span>equals(<span class="pl-s1"><span class="pl-pds">"</span>ToB<span class="pl-pds">"</span></span>)) {
        <span class="pl-c">// do some error clean up job here</span>
        <span class="pl-c">// ...</span>
        <span class="pl-c">// after recovered from this exception, reset the state machine status back to normal</span>
        setStatus(<span class="pl-stj">StateMachineStatus</span><span class="pl-c1"><span class="pl-k">.</span>IDLE</span>);
    } <span class="pl-k">else</span> <span class="pl-k">if</span>(<span class="pl-c1">...</span>) {
        <span class="pl-c">// recover from other exception ...</span>
    } <span class="pl-k">else</span> {
        <span class="pl-v">super</span><span class="pl-k">.</span>afterTransitionCausedException(fromState, toState, event, context);
    }
}</pre></div>
</li>
</ul>

<h3>
<a id="advanced-feature" class="anchor" href="#advanced-feature" aria-hidden="true"><span class="octicon octicon-link"></span></a>Advanced Feature</h3>

<ul>
<li>
<p><strong>Define Hierarchical State</strong><br>
A hierarchical state may contain nested state. The child states may themselves have nested children and the nesting may proceed to any depth. When a hierarchical state is active, one and only one of its child states is active. The hierarchical state can be defined through API or annotation.</p>

<div class="highlight highlight-java"><pre><span class="pl-st">void</span> defineSequentialStatesOn(<span class="pl-stj">S</span> parentStateId, <span class="pl-stj">S</span><span class="pl-k">.</span><span class="pl-c1">..</span> childStateIds);</pre></div>

<p><em>builder.defineSequentialStatesOn(State.A, State.BinA, StateCinA)</em> defines two child states "BinA" and "CinA" under parent state "A", the first defined child state will also be the initial state of the hierarchical state "A". The same hierarchical state can also be defined through annotation, e.g.</p>

<div class="highlight highlight-java"><pre>@States({
    @State(name<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span>, entryMethodCall<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>entryA<span class="pl-pds">"</span></span>, exitMethodCall<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>exitA<span class="pl-pds">"</span></span>),
    @State(parent<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span>, name<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>BinA<span class="pl-pds">"</span></span>, entryMethodCall<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>entryBinA<span class="pl-pds">"</span></span>, exitMethodCall<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>exitBinA<span class="pl-pds">"</span></span>, initialState<span class="pl-k">=</span><span class="pl-c1">true</span>),
    @State(parent<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span>, name<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>CinA<span class="pl-pds">"</span></span>, entryMethodCall<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>entryCinA<span class="pl-pds">"</span></span>, exitMethodCall<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>exitCinA<span class="pl-pds">"</span></span>)
})</pre></div>
</li>
<li>
<p><strong>Define Parallel State</strong><br>
The parallel state encapsulates a set of child states which are simultaneously active when the parent element is active. The  parallel state can be defined through API or annotation both. e.g.<br>
<img src="http://hekailiang.github.io/squirrel/images/ParallelStates.png" alt="ParallelStates">     </p>

<div class="highlight highlight-java"><pre><span class="pl-c">// defines two region states "RegionState1" and "RegionState2" under parent parallel state "Root"</span>
builder<span class="pl-k">.</span>defineParallelStatesOn(<span class="pl-stj">MyState</span><span class="pl-k">.</span><span class="pl-stj">Root</span>, <span class="pl-stj">MyState</span><span class="pl-k">.</span><span class="pl-stj">RegionState1</span>, <span class="pl-stj">MyState</span><span class="pl-k">.</span><span class="pl-stj">RegionState2</span>);

builder<span class="pl-k">.</span>defineSequentialStatesOn(<span class="pl-stj">MyState</span><span class="pl-k">.</span><span class="pl-stj">RegionState1</span>, <span class="pl-stj">MyState</span><span class="pl-k">.</span><span class="pl-stj">State11</span>, <span class="pl-stj">MyState</span><span class="pl-k">.</span><span class="pl-stj">State12</span>);
builder<span class="pl-k">.</span>externalTransition()<span class="pl-k">.</span>from(<span class="pl-stj">MyState</span><span class="pl-k">.</span><span class="pl-stj">State11</span>)<span class="pl-k">.</span>to(<span class="pl-stj">MyState</span><span class="pl-k">.</span><span class="pl-stj">State12</span>)<span class="pl-k">.</span>on(<span class="pl-stj">MyEvent</span><span class="pl-k">.</span><span class="pl-stj">Event1</span>);

builder<span class="pl-k">.</span>defineSequentialStatesOn(<span class="pl-stj">MyState</span><span class="pl-k">.</span><span class="pl-stj">RegionState2</span>, <span class="pl-stj">MyState</span><span class="pl-k">.</span><span class="pl-stj">State21</span>, <span class="pl-stj">MyState</span><span class="pl-k">.</span><span class="pl-stj">State22</span>);
builder<span class="pl-k">.</span>externalTransition()<span class="pl-k">.</span>from(<span class="pl-stj">MyState</span><span class="pl-k">.</span><span class="pl-stj">State21</span>)<span class="pl-k">.</span>to(<span class="pl-stj">MyState</span><span class="pl-k">.</span><span class="pl-stj">State22</span>)<span class="pl-k">.</span>on(<span class="pl-stj">MyEvent</span><span class="pl-k">.</span><span class="pl-stj">Event2</span>);</pre></div>

<p>or  </p>

<div class="highlight highlight-java"><pre>@States({
    @State(name<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>Root<span class="pl-pds">"</span></span>, entryCallMethod<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>enterRoot<span class="pl-pds">"</span></span>, exitCallMethod<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>exitRoot<span class="pl-pds">"</span></span>, compositeType<span class="pl-k">=</span><span class="pl-stj">StateCompositeType</span><span class="pl-c1"><span class="pl-k">.</span>PARALLEL</span>),
    @State(parent<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>Root<span class="pl-pds">"</span></span>, name<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>RegionState1<span class="pl-pds">"</span></span>, entryCallMethod<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>enterRegionState1<span class="pl-pds">"</span></span>, exitCallMethod<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>exitRegionState1<span class="pl-pds">"</span></span>),
    @State(parent<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>Root<span class="pl-pds">"</span></span>, name<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>RegionState2<span class="pl-pds">"</span></span>, entryCallMethod<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>enterRegionState2<span class="pl-pds">"</span></span>, exitCallMethod<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>exitRegionState2<span class="pl-pds">"</span></span>)
})</pre></div>

<p>To get current sub states of the parallel state</p>

<div class="highlight highlight-java"><pre>stateMachine<span class="pl-k">.</span>getSubStatesOn(<span class="pl-stj">MyState</span><span class="pl-k">.</span><span class="pl-stj">Root</span>); <span class="pl-c">// return list of current sub states of parallel state</span></pre></div>

<p>When all the parallel states reached final state, a <strong>Finish</strong> context event will be fired.  </p>
</li>
<li>
<p><strong>Define Context Event</strong><br>
Context event means that user defined event has predefined context in the state machine. squirrel-foundation defined three type of context event for different use case.<br>
<strong>Start/Terminate Event</strong>: Event declared as start/terminate event will be used when state machine started/terminated. So user can differentiate the invoked action trigger, e.g. when state machine is starting and entering its initial state, user can differentiate these state entry action was invoked by start event.<br>
<strong>Finish Event</strong>: When all the parallel states reached final state, finish event will be automatically fired. User can define following transition based on finish event.<br>
To define the context event, user has two way, annotation or builder API.</p>

<div class="highlight highlight-java"><pre>@ContextEvent(finishEvent<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>Finish<span class="pl-pds">"</span></span>)
<span class="pl-s">static</span> <span class="pl-s">class</span> <span class="pl-en">ParallelStateMachine</span> <span class="pl-s">extends</span> <span class="pl-e">AbstractStateMachine&lt;.</span>..&gt; {
}</pre></div>

<p>or</p>

<div class="highlight highlight-java"><pre><span class="pl-st">StateMachineBuilder&lt;.</span><span class="pl-c1">..</span><span class="pl-k">&gt;</span> builder <span class="pl-k">=</span> <span class="pl-stj">StateMachineBuilderFactory</span><span class="pl-k">.</span>create(<span class="pl-c1">...</span>);
<span class="pl-c1">...</span>
builder<span class="pl-k">.</span>defineFinishEvent(<span class="pl-stj">HEvent</span><span class="pl-k">.</span><span class="pl-stj">Start</span>);
builder<span class="pl-k">.</span>defineTerminateEvent(<span class="pl-stj">HEvent</span><span class="pl-k">.</span><span class="pl-stj">Terminate</span>);
builder<span class="pl-k">.</span>defineStartEvent(<span class="pl-stj">HEvent</span><span class="pl-k">.</span><span class="pl-stj">Finish</span>);</pre></div>
</li>
<li>
<p><strong>Using History States to Save and Restore the Current State</strong><br>
The history pseudo-state allows a state machine to remember its state configuration. A transition taking the history state as its target will return the state machine to this recorded configuration. If the 'type' of a history is "shallow", the state machine processor must record the direct  active children of its parent before taking any transition that exits the parent. If the 'type' of a history is "deep", the state machine processor must record all the active  descendants of the parent before taking any transition that exits the parent.<br>
Both API and annotation are supported to define history type of state. e.g.  </p>

<div class="highlight highlight-java"><pre><span class="pl-c">// defined history type of state "A" as "deep"</span>
builder<span class="pl-k">.</span>defineSequentialStatesOn(<span class="pl-stj">MyState</span><span class="pl-k">.</span><span class="pl-stj">A</span>, <span class="pl-stj">HistoryType</span><span class="pl-c1"><span class="pl-k">.</span>DEEP</span>, <span class="pl-stj">MyState</span><span class="pl-c1"><span class="pl-k">.</span>A1</span>, <span class="pl-stj">MyState</span><span class="pl-c1"><span class="pl-k">.</span>A2</span>)</pre></div>

<p>or</p>

<div class="highlight highlight-java"><pre>@State(parent<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span>, name<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>A1<span class="pl-pds">"</span></span>, entryCallMethod<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>enterA1<span class="pl-pds">"</span></span>, exitCallMethod<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>exitA1<span class="pl-pds">"</span></span>, historyType<span class="pl-k">=</span><span class="pl-stj">HistoryType</span><span class="pl-c1"><span class="pl-k">.</span>DEEP</span>)</pre></div>
</li>
<li>
<p><strong>Transition Types</strong><br>
According to the UML specification, a transition may be one of these three kinds:    </p>

<blockquote>
<ul>
<li>
<em>Internal Transition</em><br>
Implies that the Transition, if triggered, occurs without exiting or entering the source State (i.e., it does not cause a state change). This means that the entry or exit condition of the source State will not be invoked. An internal Transition can be taken even if the StateMachine is in one or more Regions nested within the associated State.<br>
</li>
<li>
<em>Local Transition</em><br>
Implies that the Transition, if triggered, will not exit the composite (source) State, but it will exit and re-enter any state within the composite State that is in the current state configuration.</li>
<li>
<em>External Transition</em><br>
Implies that the Transition, if triggered, will exit the composite (source) State<br>
</li>
</ul>
</blockquote>

<p>squirrel-foundation supports both API and annotation to declare all kinds of transitions, e.g.  </p>

<div class="highlight highlight-java"><pre>builder<span class="pl-k">.</span>externalTransition()<span class="pl-k">.</span>from(<span class="pl-stj">MyState</span><span class="pl-k">.</span><span class="pl-stj">A</span>)<span class="pl-k">.</span>to(<span class="pl-stj">MyState</span><span class="pl-k">.</span><span class="pl-stj">B</span>)<span class="pl-k">.</span>on(<span class="pl-stj">MyEvent</span><span class="pl-c1"><span class="pl-k">.</span>A2B</span>);
builder<span class="pl-k">.</span>internalTransition()<span class="pl-k">.</span>within(<span class="pl-stj">MyState</span><span class="pl-k">.</span><span class="pl-stj">A</span>)<span class="pl-k">.</span>on(<span class="pl-stj">MyEvent</span><span class="pl-k">.</span>innerA);
builder<span class="pl-k">.</span>localTransition()<span class="pl-k">.</span>from(<span class="pl-stj">MyState</span><span class="pl-k">.</span><span class="pl-stj">A</span>)<span class="pl-k">.</span>to(<span class="pl-stj">MyState</span><span class="pl-k">.</span><span class="pl-stj">CinA</span>)<span class="pl-k">.</span>on(<span class="pl-stj">MyEvent</span><span class="pl-k">.</span>intoC)</pre></div>

<p>or  </p>

<div class="highlight highlight-java"><pre>@Transitions({
    @Transition(from<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span>, to<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>B<span class="pl-pds">"</span></span>, on<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>A2B<span class="pl-pds">"</span></span>), <span class="pl-c">//default value of transition type is EXTERNAL</span>
    @Transition(from<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span>, on<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>innerA<span class="pl-pds">"</span></span>, type<span class="pl-k">=</span><span class="pl-stj">TransitionType</span><span class="pl-c1"><span class="pl-k">.</span>INTERNAL</span>),
    @Transition(from<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span>, to<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>CinA<span class="pl-pds">"</span></span>, on<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>intoC<span class="pl-pds">"</span></span>, type<span class="pl-k">=</span><span class="pl-stj">TransitionType</span><span class="pl-c1"><span class="pl-k">.</span>LOCAL</span>),
})</pre></div>
</li>
<li>
<p><strong>Polymorphism Event Dispatch</strong><br>
During the lifecycle of the state machine, various events will be fired, e.g.   </p>

<pre><code>State Machine Lifecycle Events
|--StateMachineEvent                        /* Base event of all state machine event */   
   |--StartEvent                            /* Fired when state machine started      */ 
   |--TerminateEvent                        /* Fired when state machine terminated   */ 
   |--TransitionEvent                       /* Base event of all transition event    */ 
        |--TransitionBeginEvent             /* Fired when transition began           */ 
        |--TransitionCompleteEvent          /* Fired when transition completed       */ 
        |--TransitionExceptionEvent         /* Fired when transition threw exception */ 
        |--TransitionDeclinedEvent          /* Fired when transition declined        */ 
        |--TransitionEndEvent               /* Fired when transition end no matter declined or complete */ 
</code></pre>

<p>User can add a listener to listen StateMachineEvent, which means all events fired during state machine lifecycle will be caught by this listener, e.g.,</p>

<div class="highlight highlight-java"><pre>stateMachine<span class="pl-k">.</span>addStateMachineListener(<span class="pl-k">new</span> <span class="pl-st">StateMachineListener&lt;.</span>..&gt;() {
        <span class="pl-st">@Override</span>
        <span class="pl-s">public</span> <span class="pl-st">void</span> <span class="pl-en">stateMachineEvent</span>(<span class="pl-st">StateMachineEvent&lt;.</span>..&gt; <span class="pl-v">event</span>) {
            <span class="pl-c">// ...</span>
        }
});</pre></div>

<p><strong>And</strong> User can also add a listener to listen TransitionEvent through StateMachine.addTransitionListener, which means all events fired during each state transition including TransitionBeginEvent, TransitionCompleteEvent and TransitionEndEvent will be caught by this listener.<br>
<strong>Or</strong> user can add specific listener e.g. TransitionDeclinedListener to listen TransitionDeclinedEvent when transition request was declined.  </p>
</li>
<li>
<p><strong>Declarative Event Listener</strong><br>
Adding above event listener to state machine sometime annoying to user, and too many generic types also makes code ugly to read. To simplify state machine usage, more important to provide a non-invasive integration, squirrel-foundation provides a declarative way to add event listener through following annotation, e.g.     </p>

<div class="highlight highlight-java"><pre><span class="pl-s">static</span> <span class="pl-s">class</span> <span class="pl-en">ExternalModule</span> {
    <span class="pl-st">@OnTransitionEnd</span>
    <span class="pl-st">@ListenerOrder</span>(<span class="pl-c1">10</span>) <span class="pl-c">// Since 0.3.1 ListenerOrder can be used to insure listener invoked orderly</span>
    <span class="pl-s">public</span> <span class="pl-st">void</span> <span class="pl-en">transitionEnd</span>() {
        <span class="pl-c">// method annotated with TransitionEnd will be invoked when transition end...</span>
        <span class="pl-c">// the method must be public and return nothing</span>
    }

    <span class="pl-st">@OnTransitionBegin</span>
    <span class="pl-s">public</span> <span class="pl-st">void</span> <span class="pl-en">transitionBegin</span>(<span class="pl-stj">TestEvent</span> <span class="pl-v">event</span>) {
        <span class="pl-c">// method annotated with TransitionBegin will be invoked when transition begin...</span>
    }

    <span class="pl-c">// 'event'(E), 'from'(S), 'to'(S), 'context'(C) and 'stateMachine'(T) can be used in MVEL scripts       </span>
    <span class="pl-st">@OnTransitionBegin</span>(<span class="pl-c1">when</span><span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>event.name().equals(<span class="pl-cce">\"</span>toB<span class="pl-cce">\"</span>)<span class="pl-pds">"</span></span>)
    <span class="pl-s">public</span> <span class="pl-st">void</span> <span class="pl-en">transitionBeginConditional</span>() {
        <span class="pl-c">// method will be invoked when transition begin while transition caused by event "toB"</span>
    }

    <span class="pl-st">@OnTransitionComplete</span>
    <span class="pl-s">public</span> <span class="pl-st">void</span> <span class="pl-en">transitionComplete</span>(<span class="pl-stj">String</span> <span class="pl-v">from</span>, <span class="pl-stj">String</span> <span class="pl-v">to</span>, <span class="pl-stj">TestEvent</span> <span class="pl-v">event</span>, <span class="pl-stj">Integer</span> <span class="pl-v">context</span>) {
        <span class="pl-c">// method annotated with TransitionComplete will be invoked when transition complete...</span>
    }

    <span class="pl-st">@OnTransitionDecline</span>
    <span class="pl-s">public</span> <span class="pl-st">void</span> <span class="pl-en">transitionDeclined</span>(<span class="pl-stj">String</span> <span class="pl-v">from</span>, <span class="pl-stj">TestEvent</span> <span class="pl-v">event</span>, <span class="pl-stj">Integer</span> <span class="pl-v">context</span>) {
        <span class="pl-c">// method annotated with TransitionDecline will be invoked when transition declined...</span>
    }

    <span class="pl-st">@OnBeforeActionExecuted</span>
    <span class="pl-s">public</span> <span class="pl-st">void</span> <span class="pl-en">onBeforeActionExecuted</span>(<span class="pl-stj">Object</span> <span class="pl-v">sourceState</span>, <span class="pl-stj">Object</span> <span class="pl-v">targetState</span>, 
            <span class="pl-stj">Object</span> <span class="pl-v">event</span>, <span class="pl-stj">Object</span> <span class="pl-v">context</span>, <span class="pl-st">int</span>[] <span class="pl-v">mOfN</span>, <span class="pl-st">Action&lt;?, ?, ?,?&gt;</span> <span class="pl-v">action</span>) {
        <span class="pl-c">// method annotated with OnAfterActionExecuted will be invoked before action invoked  </span>
    }

    <span class="pl-st">@OnAfterActionExecuted</span>
    <span class="pl-s">public</span> <span class="pl-st">void</span> <span class="pl-en">onAfterActionExecuted</span>(<span class="pl-stj">Object</span> <span class="pl-v">sourceState</span>, <span class="pl-stj">Object</span> <span class="pl-v">targetState</span>, 
            <span class="pl-stj">Object</span> <span class="pl-v">event</span>, <span class="pl-stj">Object</span> <span class="pl-v">context</span>, <span class="pl-st">int</span>[] <span class="pl-v">mOfN</span>, <span class="pl-st">Action&lt;?, ?, ?,?&gt;</span> <span class="pl-v">action</span>) {
        <span class="pl-c">// method annotated with OnAfterActionExecuted will be invoked after action invoked  </span>
    }

    <span class="pl-st">@OnActionExecException</span>
    <span class="pl-s">public</span> <span class="pl-st">void</span> <span class="pl-en">onActionExecException</span>(<span class="pl-st">Action&lt;?, ?, ?,?&gt;</span> <span class="pl-v">action</span>, <span class="pl-stj">TransitionException</span> <span class="pl-v">e</span>) {
        <span class="pl-c">// method annotated with OnActionExecException will be invoked when action thrown exception  </span>
    }
}

<span class="pl-stj">ExternalModule</span> externalModule <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-stj">ExternalModule</span>();
fsm<span class="pl-k">.</span>addDeclarativeListener(externalModule);
<span class="pl-c1">...</span>
fsm<span class="pl-k">.</span>removeDeclarativeListener(externalModule);</pre></div>

<p>By doing this external module code does not need to implement any state machine listener interface. Only add few annotations on methods which will be hooked during transition phase. The parameters of method is also type safe, and will automatically be inferred to match corresponding event. This is a good approach for <strong>Separation of Concerns</strong>. User can find sample usage in <em>org.squirrelframework.foundation.fsm.StateMachineLogger</em>.</p>
</li>
<li>
<p><strong>Transition Extension Methods</strong><br>
Each transition event also has corresponding extension method on AbstractStateMachine class which is allowed to be extended in customer state machine implementation class.  </p>

<div class="highlight highlight-java"><pre><span class="pl-s">protected</span> <span class="pl-st">void</span> afterTransitionCausedException(<span class="pl-stj">Exception</span> e, <span class="pl-stj">S</span> fromState, <span class="pl-stj">S</span> toState, <span class="pl-stj">E</span> event, <span class="pl-stj">C</span> context) {
}

<span class="pl-s">protected</span> <span class="pl-st">void</span> beforeTransitionBegin(<span class="pl-stj">S</span> fromState, <span class="pl-stj">E</span> event, <span class="pl-stj">C</span> context) {
}

<span class="pl-s">protected</span> <span class="pl-st">void</span> afterTransitionCompleted(<span class="pl-stj">S</span> fromState, <span class="pl-stj">S</span> toState, <span class="pl-stj">E</span> event, <span class="pl-stj">C</span> context) {
}

<span class="pl-s">protected</span> <span class="pl-st">void</span> afterTransitionEnd(<span class="pl-stj">S</span> fromState, <span class="pl-stj">S</span> toState, <span class="pl-stj">E</span> event, <span class="pl-stj">C</span> context) {
}

<span class="pl-s">protected</span> <span class="pl-st">void</span> afterTransitionDeclined(<span class="pl-stj">S</span> fromState, <span class="pl-stj">E</span> event, <span class="pl-stj">C</span> context) {
}

<span class="pl-s">protected</span> <span class="pl-st">void</span> beforeActionInvoked(<span class="pl-stj">S</span> fromState, <span class="pl-stj">S</span> toState, <span class="pl-stj">E</span> event, <span class="pl-stj">C</span> context) {
}</pre></div>

<p>Typically, user can hook in your business processing logic in these extension methods during each state transition, while the various event listener serves as boundary of state machine based control system, which can interact with external modules (e.g. UI, Auditing, ESB and so on).<br>
For example, user can extend the method afterTransitionCausedException for environment clean up when exception happened during transition, and also notify user interface module to display error message  through TransitionExceptionEvent.  </p>
</li>
<li>
<p><strong>Weighted Action</strong><br>
User can define action weight to adjust action execution order. The actions during state entry/exit and state transition are ordered in ascending order according to their weight value. Action weight is 0 by default. User has two way to set action weight.<br>
One is append weight number to method name and separated by ':'.</p>

<div class="highlight highlight-java"><pre><span class="pl-c">// define state entry action 'goEntryD' weight -150</span>
@State(name<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>D<span class="pl-pds">"</span></span>, entryCallMethod<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>goEntryD:-150<span class="pl-pds">"</span></span>) 
<span class="pl-c">// define transition action 'goAToC1' weight +150</span>
@Transit(from<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span>, to<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span>, on<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>ToC<span class="pl-pds">"</span></span>, callMethod<span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">"</span>goAToC1:+150<span class="pl-pds">"</span></span>) </pre></div>

<p>Another way is override weight method of Action class, e.g. </p>

<div class="highlight highlight-java"><pre><span class="pl-st">Action&lt;.</span><span class="pl-c1">..</span><span class="pl-k">&gt;</span> newAction <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-st">Action&lt;.</span>..&gt;() {
    <span class="pl-c1">...</span>
    <span class="pl-st">@Override</span>
    <span class="pl-s">public</span> <span class="pl-st">int</span> <span class="pl-en">weight</span>() {
        <span class="pl-k">return</span> <span class="pl-c1">100</span>;
    }
}</pre></div>

<p>squirrel-foundation also support a conventional manner to declare action weight. The weight of method call action whose name started with '<em>before</em>' will be set to 100, so as the name started with '<em>after</em>' will be set to -100. Generally it means that the action method name started with 'before' will be invoked at first, while the action method name started with 'after' will be invoked at last. "method1:ignore" means method1 will not be invoked.<br>
For more information, please refer to test case '<em>org.squirrelframework.foundation.fsm.WeightedActionTest</em>';  </p>
</li>
<li>
<p><strong>Asynchronized Execution</strong><br>
<strong>@AsyncExecute</strong> annotation can be used on method call action and declarative event listener to indicate that this action or event listener will be executed asynchronously, e.g.<br>
Define asynchronously invoked action method:</p>

<div class="highlight highlight-java"><pre>@<span class="pl-stj">ContextInsensitive</span>
@StateMachineParameters(stateType<span class="pl-k">=</span><span class="pl-stj">String</span><span class="pl-k">.</span>class, eventType<span class="pl-k">=</span><span class="pl-stj">String</span><span class="pl-k">.</span>class, contextType<span class="pl-k">=</span><span class="pl-stj">Void</span><span class="pl-k">.</span>class)
<span class="pl-s">public</span> <span class="pl-s">class</span> <span class="pl-en">ConcurrentSimpleStateMachine</span> <span class="pl-s">extends</span> <span class="pl-e">AbstractUntypedStateMachine</span> {
    <span class="pl-c">// No need to specify constructor anymore since 0.2.9</span>
    <span class="pl-c">// protected ConcurrentSimpleStateMachine(ImmutableUntypedState initialState, </span>
    <span class="pl-c">//    Map&lt;Object, ImmutableUntypedState&gt; states) {</span>
    <span class="pl-c">//  super(initialState, states);</span>
    <span class="pl-c">// }</span>

    <span class="pl-st">@AsyncExecute</span>
    <span class="pl-s">protected</span> <span class="pl-st">void</span> <span class="pl-en">fromAToB</span>(<span class="pl-stj">String</span> <span class="pl-v">from</span>, <span class="pl-stj">String</span> <span class="pl-v">to</span>, <span class="pl-stj">String</span> <span class="pl-v">event</span>) {
        <span class="pl-c">// this action method will be invoked asynchronously</span>
    }
}</pre></div>

<p>Define asynchronously dispatched event:  </p>

<div class="highlight highlight-java"><pre><span class="pl-s">public</span> <span class="pl-s">class</span> <span class="pl-en">DeclarativeListener</span> {
    <span class="pl-st">@OnTransitionBegin</span>
    <span class="pl-st">@AsyncExecute</span>
    <span class="pl-s">public</span> <span class="pl-st">void</span> <span class="pl-en">onTransitionBegin</span>(...) {
        <span class="pl-c">// transition begin event will be dispatched asynchronously to this listener method</span>
    }
}</pre></div>

<p>Asynchronous execution task will be submit to a <em>ExecutorService</em>. User can register your ExecutorService implementation instance through <em>SquirrelSingletonProvider</em>, e.g.  </p>

<div class="highlight highlight-java"><pre><span class="pl-stj">ExecutorService</span> executorService <span class="pl-k">=</span> <span class="pl-stj">Executors</span><span class="pl-k">.</span>newFixedThreadPool(<span class="pl-c1">1</span>);
<span class="pl-stj">SquirrelSingletonProvider</span><span class="pl-k">.</span>getInstance()<span class="pl-k">.</span>register(<span class="pl-stj">ExecutorService</span><span class="pl-k">.</span>class, executorService);</pre></div>

<p>If no ExecutorService instance was registered, <em>SquirrelConfiguration</em> will provide a default one.</p>
</li>
<li>
<p><strong>State Machine PostProcessor</strong><br>
User can register post processor for specific type of state machine in order to adding post process logic after state machine instantiated, e.g.  </p>

<div class="highlight highlight-java"><pre><span class="pl-c">// 1 User defined a state machine interface</span>
<span class="pl-s">interface</span> <span class="pl-en">MyStateMachine</span> <span class="pl-s">extends</span> <span class="pl-e">StateMachine&lt;<span class="pl-stj">MyStateMachine</span>, <span class="pl-stj">MyState</span>, <span class="pl-stj">MyEvent</span>, <span class="pl-stj">MyContext</span>&gt;</span> {
<span class="pl-c1">.</span> <span class="pl-c1">.</span> <span class="pl-c1">.</span>
}

<span class="pl-c">// 2 Both MyStateMachineImpl and MyStateMachineImplEx are implemented MyStateMachine</span>
<span class="pl-s">class</span> <span class="pl-en">MyStateMachineImpl</span> <span class="pl-s">implements</span> <span class="pl-e">MyStateMachine</span> {
    <span class="pl-c1">.</span> <span class="pl-c1">.</span> <span class="pl-c1">.</span> 
}
<span class="pl-s">class</span> <span class="pl-en">MyStateMachineImplEx</span> <span class="pl-s">implements</span> <span class="pl-e">MyStateMachine</span> {
    <span class="pl-c1">.</span> <span class="pl-c1">.</span> <span class="pl-c1">.</span>
}

<span class="pl-c">// 3 User define a state machine post processor</span>
<span class="pl-stj">MyStateMachinePostProcessor</span> implements <span class="pl-st">SquirrelPostProcessor&lt;<span class="pl-stj">MyStateMachine</span>&gt;</span> {
    <span class="pl-st">void</span> postProcess(<span class="pl-stj">MyStateMachine</span> component) {
        <span class="pl-c1">.</span> <span class="pl-c1">.</span> <span class="pl-c1">.</span> 
    }
}  

<span class="pl-c">// 4 User register state machine post process</span>
<span class="pl-stj">SquirrelPostProcessorProvider</span><span class="pl-k">.</span>getInstance()<span class="pl-k">.</span>register(<span class="pl-stj">MyStateMachine</span><span class="pl-k">.</span>class, <span class="pl-stj">MyStateMachinePostProcessor</span><span class="pl-k">.</span>class);</pre></div>

<p>For this case, when user created both MyStateMachineImpl and MyStateMachineImplEx instance, the registered post processor MyStateMachinePostProcessor will be called to do some work.</p>
</li>
<li>
<p><strong>State Machine Export</strong><br>
<strong>SCXMLVisitor</strong> can be used to export state machine definition in <a href="http://www.w3.org/TR/scxml/">SCXML</a> document.</p>

<div class="highlight highlight-java"><pre><span class="pl-stj">SCXMLVisitor</span> visitor <span class="pl-k">=</span> <span class="pl-stj">SquirrelProvider</span><span class="pl-k">.</span>getInstance()<span class="pl-k">.</span>newInstance(<span class="pl-stj">SCXMLVisitor</span><span class="pl-k">.</span>class);
stateMachine<span class="pl-k">.</span>accept(visitor);
visitor<span class="pl-k">.</span>convertSCXMLFile(<span class="pl-s1"><span class="pl-pds">"</span>MyStateMachine<span class="pl-pds">"</span></span>, <span class="pl-c1">true</span>);</pre></div>

<p>BTW, user can also call <em>StateMachine.exportXMLDefinition(true)</em> to export beautified XML definition.<br>
<strong>DotVisitor</strong> can be used to generate state diagram which can be viewed by <a href="http://www.graphviz.org/">GraphViz</a>.</p>

<div class="highlight highlight-java"><pre><span class="pl-stj">DotVisitor</span> visitor <span class="pl-k">=</span> <span class="pl-stj">SquirrelProvider</span><span class="pl-k">.</span>getInstance()<span class="pl-k">.</span>newInstance(<span class="pl-stj">DotVisitor</span><span class="pl-k">.</span>class);
stateMachine<span class="pl-k">.</span>accept(visitor);
visitor<span class="pl-k">.</span>convertDotFile(<span class="pl-s1"><span class="pl-pds">"</span>SnakeStateMachine<span class="pl-pds">"</span></span>);</pre></div>
</li>
<li>
<p><strong>State Machine Import</strong><br>
<strong>UntypedStateMachineImporter</strong> can be used to import state machine SCXML-similar definition which was  exported by SCXMLVisitor or handwriting definition. UntypedStateMachineImporter will build a UntypedStateMachineBuilder according to the definition which can later be used to create state machine instances.  </p>

<div class="highlight highlight-java"><pre><span class="pl-stj">UntypedStateMachineBuilder</span> builder <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-stj">UntypedStateMachineImporter</span>()<span class="pl-k">.</span>importDefinition(scxmlDef);
<span class="pl-stj">ATMStateMachine</span> stateMachine <span class="pl-k">=</span> builder<span class="pl-k">.</span>newAnyStateMachine(<span class="pl-stj">ATMState</span><span class="pl-k">.</span><span class="pl-stj">Idle</span>);</pre></div>

<p><em>Note: The UntypedStateMachineImporter provided an XML-style to define the state machine just like the state machine builder API or declarative annotations. The SCXML-similar definition is not equal to standard SCXML.</em>   </p>
</li>
<li>
<p><strong>Save/Load State Machine Data</strong><br>
User can save data of state machine when state machine is in idle status.</p>

<div class="highlight highlight-java"><pre><span class="pl-stj">StateMachineData</span><span class="pl-k">.</span><span class="pl-st">Reader&lt;<span class="pl-stj">MyStateMachine</span>, <span class="pl-stj">MyState</span>, <span class="pl-stj">MyEvent</span>, <span class="pl-stj">MyContext</span>&gt;</span> 
    savedData <span class="pl-k">=</span> stateMachine<span class="pl-k">.</span>dumpSavedData();</pre></div>

<p>And also user can load above <em>savedData</em> into another state machine whose status is terminated or just initialized.</p>

<div class="highlight highlight-java"><pre>newStateMachineInstance<span class="pl-k">.</span>loadSavedData(savedData);</pre></div>

<p><strong>NOTE</strong>: The state machine data can be serialized to/deserialized from Base64 encoded string with the help of <em>ObjectSerializableSupport</em> class.</p>
</li>
<li>
<p><strong>State Machine Configuration</strong><br>
When creating new state machine instance, user can configure its behavior through   <em>StateMachineConfiguration</em>, e.g.    </p>

<div class="highlight highlight-java"><pre><span class="pl-stj">UntypedStateMachine</span> fsm <span class="pl-k">=</span> builder<span class="pl-k">.</span>newUntypedStateMachine(<span class="pl-s1"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, 
     <span class="pl-stj">StateMachineConfiguration</span><span class="pl-k">.</span>create()<span class="pl-k">.</span>enableAutoStart(<span class="pl-c1">false</span>)
            .setIdProvider(<span class="pl-stj">IdProvider</span><span class="pl-k">.</span><span class="pl-stj">UUIDProvider</span><span class="pl-k">.</span>getInstance()), 
     <span class="pl-k">new</span> <span class="pl-stj">Object</span>[<span class="pl-c1">0</span>]); <span class="pl-c">// since 0.3.0</span>
fsm<span class="pl-k">.</span>fire(<span class="pl-stj">TestEvent</span><span class="pl-k">.</span>toA);</pre></div>

<p>The sample code above is used to create a state machine instance with UUID as its identifier and disable auto start function.<br>
StateMachineConfigure can also be set on state machine builder which means all the state machine instance created by <code>builder.newStateMachine(S initialStateId)</code> or <code>builder.newStateMachine(S initialStateId, Object... extraParams)</code> will use this configuration.</p>
</li>
<li>
<p><strong>State Machine Diagnose</strong><br>
<em>StateMachineLogger</em> is used to observe internal status of the state machine, like the execution performance, action calling sequence, transition progress and so on, e.g.  </p>

<div class="highlight highlight-java"><pre><span class="pl-st">StateMachine&lt;?,?,?,?&gt;</span> stateMachine <span class="pl-k">=</span> builder<span class="pl-k">.</span>newStateMachine(<span class="pl-stj">HState</span><span class="pl-k">.</span><span class="pl-stj">A</span>);
<span class="pl-stj">StateMachineLogger</span> fsmLogger <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-stj">StateMachineLogger</span>(stateMachine);
fsmLogger<span class="pl-k">.</span>startLogging();
<span class="pl-c1">...</span>
stateMachine<span class="pl-k">.</span>fire(<span class="pl-stj">HEvent</span><span class="pl-c1"><span class="pl-k">.</span>B2A</span>, <span class="pl-c1">1</span>);
<span class="pl-c1">...</span>
fsmLogger<span class="pl-k">.</span>terminateLogging();
<span class="pl-k">------------------------------------------------------------------------------------------</span><span class="pl-k">-</span>
<span class="pl-stj">Console</span> <span class="pl-stj">Log</span><span class="pl-k">:</span>
<span class="pl-stj">HierachicalStateMachine</span><span class="pl-k">:</span> <span class="pl-stj">Transition</span> from <span class="pl-s1"><span class="pl-pds">"</span>B2a<span class="pl-pds">"</span></span> on <span class="pl-s1"><span class="pl-pds">"</span>B2A<span class="pl-pds">"</span></span> with context <span class="pl-s1"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span> begin.
<span class="pl-stj">Before</span> execute method call action <span class="pl-s1"><span class="pl-pds">"</span>leftB2a<span class="pl-pds">"</span></span> (<span class="pl-c1">1</span> of <span class="pl-c1">6</span>)<span class="pl-c1">.</span>
<span class="pl-stj">Before</span> execute method call action <span class="pl-s1"><span class="pl-pds">"</span>exitB2<span class="pl-pds">"</span></span> (<span class="pl-c1">2</span> of <span class="pl-c1">6</span>)<span class="pl-c1">.</span>
<span class="pl-c1">...</span>
<span class="pl-stj">Before</span> execute method call action <span class="pl-s1"><span class="pl-pds">"</span>entryA1<span class="pl-pds">"</span></span> (<span class="pl-c1">6</span> of <span class="pl-c1">6</span>)<span class="pl-c1">.</span>
<span class="pl-stj">HierachicalStateMachine</span><span class="pl-k">:</span> <span class="pl-stj">Transition</span> from <span class="pl-s1"><span class="pl-pds">"</span>B2a<span class="pl-pds">"</span></span> to <span class="pl-s1"><span class="pl-pds">"</span>A1<span class="pl-pds">"</span></span> on <span class="pl-s1"><span class="pl-pds">"</span>B2A<span class="pl-pds">"</span></span> complete which took 2ms.
<span class="pl-c1">...</span></pre></div>

<p><em>Since v0.3.0 state machine logger can be used more easy way by just set StateMachineConfiguration enable debug mode to ture, e.g.</em></p>

<pre><code>StateMachine&lt;?,?,?,?&gt; stateMachine = builder.newStateMachine(HState.A,
        StateMachineConfiguration.create().enableDebugMode(true),
        new Object[0]);
</code></pre>

<p><em>StateMachinePerformanceMonitor</em> can be used to monitor state machine execution performance information, including total transition times count, average transition consumed time and so on, e.g.</p>

<div class="highlight highlight-java"><pre><span class="pl-s">final</span> <span class="pl-stj">UntypedStateMachine</span> fsm <span class="pl-k">=</span> builder<span class="pl-k">.</span>newStateMachine(<span class="pl-s1"><span class="pl-pds">"</span>D<span class="pl-pds">"</span></span>);
<span class="pl-s">final</span> <span class="pl-stj">StateMachinePerformanceMonitor</span> performanceMonitor <span class="pl-k">=</span> 
            <span class="pl-k">new</span> <span class="pl-stj">StateMachinePerformanceMonitor</span>(<span class="pl-s1"><span class="pl-pds">"</span>Sample State Machine Performance Info<span class="pl-pds">"</span></span>);
fsm<span class="pl-k">.</span>addDeclarativeListener(performanceMonitor);
<span class="pl-k">for</span> (<span class="pl-st">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-c1">10000</span>; i<span class="pl-k">++</span>) {
    fsm<span class="pl-k">.</span>fire(<span class="pl-stj">FSMEvent</span><span class="pl-k">.</span><span class="pl-stj">ToA</span>, <span class="pl-c1">10</span>);
    fsm<span class="pl-k">.</span>fire(<span class="pl-stj">FSMEvent</span><span class="pl-k">.</span><span class="pl-stj">ToB</span>, <span class="pl-c1">10</span>);
    fsm<span class="pl-k">.</span>fire(<span class="pl-stj">FSMEvent</span><span class="pl-k">.</span><span class="pl-stj">ToC</span>, <span class="pl-c1">10</span>);
    fsm<span class="pl-k">.</span>fire(<span class="pl-stj">FSMEvent</span><span class="pl-k">.</span><span class="pl-stj">ToD</span>, <span class="pl-c1">10</span>);
}
fsm<span class="pl-k">.</span>removeDeclarativeListener(performanceMonitor);
<span class="pl-stj">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(performanceMonitor<span class="pl-k">.</span>getPerfModel());
<span class="pl-k">------------------------------------------------------------------------------------------</span><span class="pl-k">-</span>
<span class="pl-stj">Console</span> <span class="pl-stj">Log</span><span class="pl-k">:</span>
<span class="pl-k">==========================</span> <span class="pl-stj">Sample</span> <span class="pl-stj">State</span> <span class="pl-stj">Machine</span> <span class="pl-stj">Performance</span> <span class="pl-stj">Info</span> <span class="pl-k">==========================</span>
<span class="pl-stj">Total</span> <span class="pl-stj">Transition</span> <span class="pl-stj">Invoked</span><span class="pl-k">:</span> <span class="pl-c1">40000</span>
<span class="pl-stj">Total</span> <span class="pl-stj">Transition</span> <span class="pl-stj">Failed</span><span class="pl-k">:</span> <span class="pl-c1">0</span>
<span class="pl-stj">Total</span> <span class="pl-stj">Transition</span> <span class="pl-stj">Declained</span><span class="pl-k">:</span> <span class="pl-c1">0</span>
<span class="pl-stj">Average</span> <span class="pl-stj">Transition</span> <span class="pl-stj">Comsumed</span><span class="pl-k">:</span> 0<span class="pl-k">.</span>0004ms
    <span class="pl-stj">Transition</span> <span class="pl-stj">Key</span>      <span class="pl-stj">Invoked</span> <span class="pl-stj">Times</span>   <span class="pl-stj">Average</span> <span class="pl-stj">Time</span>        <span class="pl-stj">Max</span> <span class="pl-stj">Time</span>    <span class="pl-stj">Min</span> <span class="pl-stj">Time</span>
    <span class="pl-stj">C</span><span class="pl-k">--</span>{<span class="pl-stj">ToD</span>, <span class="pl-c1">10</span>}<span class="pl-k">-</span><span class="pl-k">&gt;</span><span class="pl-stj">D</span>     <span class="pl-c1">10000</span>           0<span class="pl-k">.</span>0007ms            5ms         0ms     
    <span class="pl-stj">B</span><span class="pl-k">--</span>{<span class="pl-stj">ToC</span>, <span class="pl-c1">10</span>}<span class="pl-k">-</span><span class="pl-k">&gt;</span><span class="pl-stj">C</span>     <span class="pl-c1">10000</span>           0<span class="pl-k">.</span>0001ms            1ms         0ms     
    <span class="pl-stj">D</span><span class="pl-k">--</span>{<span class="pl-stj">ToA</span>, <span class="pl-c1">10</span>}<span class="pl-k">-</span><span class="pl-k">&gt;</span><span class="pl-stj">A</span>     <span class="pl-c1">10000</span>           0<span class="pl-k">.</span>0009ms            7ms         0ms     
    <span class="pl-stj">A</span><span class="pl-k">--</span>{<span class="pl-stj">ToB</span>, <span class="pl-c1">10</span>}<span class="pl-k">-</span><span class="pl-k">&gt;</span><span class="pl-stj">B</span>     <span class="pl-c1">10000</span>           0<span class="pl-k">.</span>0000ms            1ms         0ms     
<span class="pl-stj">Total</span> <span class="pl-stj">Action</span> <span class="pl-stj">Invoked</span><span class="pl-k">:</span> <span class="pl-c1">40000</span>
<span class="pl-stj">Total</span> <span class="pl-stj">Action</span> <span class="pl-stj">Failed</span><span class="pl-k">:</span> <span class="pl-c1">0</span>
<span class="pl-stj">Average</span> <span class="pl-stj">Action</span> <span class="pl-stj">Execution</span> <span class="pl-stj">Comsumed</span><span class="pl-k">:</span> 0<span class="pl-k">.</span>0000ms
    <span class="pl-stj">Action</span> <span class="pl-stj">Key</span>          <span class="pl-stj">Invoked</span> <span class="pl-stj">Times</span>   <span class="pl-stj">Average</span> <span class="pl-stj">Time</span>        <span class="pl-stj">Max</span> <span class="pl-stj">Time</span>    <span class="pl-stj">Min</span> <span class="pl-stj">Time</span>
    instan<span class="pl-k">.</span><span class="pl-c1">.</span><span class="pl-k">.</span><span class="pl-stj">Test</span>$<span class="pl-c1">1</span>     <span class="pl-c1">40000</span>           0<span class="pl-k">.</span>0000ms            1ms         0ms 
<span class="pl-k">==========================</span> <span class="pl-stj">Sample</span> <span class="pl-stj">State</span> <span class="pl-stj">Machine</span> <span class="pl-stj">Performance</span> <span class="pl-stj">Info</span> <span class="pl-k">==========================</span></pre></div>

<p>Add <strong>@LogExecTime</strong> on action method will log out the execution time of the method. And also add the @LogExecTime on state machine class will log out all the action method execution time. For example, the execution time of method <em>transitFromAToBOnGoToB</em> will be logged out.</p>

<div class="highlight highlight-java"><pre>@<span class="pl-stj">LogExecTime</span>
<span class="pl-s">protected</span> <span class="pl-st">void</span> transitFromAToBOnGoToB(<span class="pl-stj">MyState</span> from, <span class="pl-stj">MyState</span> to, <span class="pl-stj">MyEvent</span> event, <span class="pl-stj">MyContext</span> context)</pre></div>
</li>
<li>
<p><strong>Timed State</strong><br>
A <strong>timed state</strong> is a state that can delay or periodically trigger specified event after state entered. Timed task will be submit to a <em>ScheduledExecutorService</em>. User can register your ScheduledExecutorService implementation instance through <em>SquirrelSingletonProvider</em>, e.g.  </p>

<div class="highlight highlight-java"><pre><span class="pl-stj">ScheduledExecutorService</span> scheduler <span class="pl-k">=</span> <span class="pl-stj">Executors</span><span class="pl-k">.</span>newScheduledThreadPool(<span class="pl-c1">1</span>);
<span class="pl-stj">SquirrelSingletonProvider</span><span class="pl-k">.</span>getInstance()<span class="pl-k">.</span>register(<span class="pl-stj">ScheduledExecutorService</span><span class="pl-k">.</span>class, scheduler);</pre></div>

<p>If no ScheduledExecutorService instance was registered, <em>SquirrelConfiguration</em> will provide a default one. After that, a timed state can be defined by state machine builder, e.g.  </p>

<div class="highlight highlight-java"><pre><span class="pl-c">// after 50ms delay fire event "FIRST" every 100ms with null context</span>
builder<span class="pl-k">.</span>defineTimedState(<span class="pl-s1"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span>, <span class="pl-c1">50</span>, <span class="pl-c1">100</span>, <span class="pl-s1"><span class="pl-pds">"</span>FIRST<span class="pl-pds">"</span></span>, <span class="pl-c1">null</span>);
builder<span class="pl-k">.</span>internalTransition()<span class="pl-k">.</span>within(<span class="pl-s1"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>on(<span class="pl-s1"><span class="pl-pds">"</span>FIRST<span class="pl-pds">"</span></span>);   </pre></div>

<p><strong>NOTE</strong>: Make sure timed state must be defined before describe its transitions or entry/exit actions. <em>timeInterval</em> less than or equal to 0 will be considered only execute once after <em>initialDelay</em>.</p>
</li>
<li>
<p><strong>Linked State (so called Submachine State)</strong><br>
A <strong>linked state</strong> specifies the insertion of the specification of a submachine state machine. The state machine that contains the linked state is called the containing state machine. The same state machine may be a submachine more than once in the context of a single containing state machine.  </p>

<p>A linked state is semantically equivalent to a composite state. The regions of the submachine state machine are the regions of the composite state. The entry, exit, and behavior actions and internal transitions are defined as part of the state. Submachine state is a decomposition mechanism that allows factoring of common behaviors and their reuse.<br>
The linked state can be defined by following sample code.</p>

<div class="highlight highlight-java"><pre>builderOfTestStateMachine<span class="pl-k">.</span>definedLinkedState(<span class="pl-stj">LState</span><span class="pl-k">.</span><span class="pl-stj">A</span>, builderOfLinkedStateMachine, <span class="pl-stj">LState</span><span class="pl-c1"><span class="pl-k">.</span>A1</span>); </pre></div>
</li>
<li>
<p><strong>JMX Support</strong><br>
Since 0.3.3, user can remote monitor state machine instance(e.g. current status, name) and modify configurations(e.g. toggle loggings/toggle performance monitor/remote fire event) at runtime. All the state machine instances information will be under "org.squirrelframework" domain. The following sample code shows how to enable JMX support.  </p>

<div class="highlight highlight-java"><pre><span class="pl-stj">UntypedStateMachineBuilder</span> builder <span class="pl-k">=</span> <span class="pl-stj">StateMachineBuilderFactory</span><span class="pl-k">.</span>create(<span class="pl-c1">...</span>);
builder<span class="pl-k">.</span>setStateMachineConfiguration(<span class="pl-stj">StateMachineConfiguration</span><span class="pl-k">.</span>create()<span class="pl-k">.</span>enableRemoteMonitor(<span class="pl-c1">true</span>));</pre></div>
</li>
</ul>

<h2>
<a id="examples" class="anchor" href="#examples" aria-hidden="true"><span class="octicon octicon-link"></span></a>Examples</h2>

<p>See <a href="https://github.com/hekailiang/squirrel/blob/master/EXAMPLES.md">EXAMPLES</a> file.</p>

<h2>
<a id="release-notes" class="anchor" href="#release-notes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Release Notes</h2>

<p>See <a href="https://github.com/hekailiang/squirrel/blob/master/RELEASE_NOTES.md">RELEASE NOTES</a> file.</p>

<h2>
<a id="future-plan" class="anchor" href="#future-plan" aria-hidden="true"><span class="octicon octicon-link"></span></a>Future Plan</h2>

<ul>
<li>Support health metrics monitoring<br>
</li>
<li>Support state machine definition profile(activate different profile behave differently)<br>
</li>
<li>
<a href="https://github.com/hekailiang/squirrel-statemachine-js">Javascript version of Squirrel State Machine</a> is still under development </li>
</ul>

<h2>
<a id="sponsors" class="anchor" href="#sponsors" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sponsors</h2>

<p><img src="http://www.jetbrains.com/img/logos/logo_intellij_idea.png" alt="IDEA"></p>

<h2>
<a id="more-information" class="anchor" href="#more-information" aria-hidden="true"><span class="octicon octicon-link"></span></a>More Information</h2>

<ul>
<li>For the <strong>latest updates</strong> follow my twitter <a href="https://twitter.com/hhe11">@hhe11</a> or <a href="https://google.com/+HeHenry">+HeHenry</a>
</li>
<li>For discussions or questions please join the <a href="http://groups.google.com/group/squirrel-state-machine">squirrel state machine group</a>
</li>
<li>For any issue or requirement, please submit an <a href="https://github.com/hekailiang/squirrel/issues?state=open">issue</a><br>
</li>
<li>
<p><strong>If you use Squirrel State Machine code in your application, I'll be appreciate if you inform the author about it (email: <a href="mailto:hekailiang@gmail.com">hekailiang@gmail.com</a>) like this</strong>:  </p>

<p><strong>Subject:</strong> Squirrel State Machine Usage Notification<br>
<strong>Text:</strong> I use Squirrel State Machine &lt;lib_version&gt; in &lt;project_name&gt; - http://link_to_project. I [allow | don't allow] to mention my project in section "Who using Squirrel State Machine" on GitHub.</p>
</li>
</ul>
      </section>

    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>